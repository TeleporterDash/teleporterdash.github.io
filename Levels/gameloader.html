<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Level 1</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
            transition: background-color 1s ease;
        }
        #gameContainer {
            position: relative;
            width: 1000px;
            height: 400px;
            overflow: hidden;
            perspective: 1000px;
            transition: none;
            --from-color: #000000;
            --to-color: #000000;
            background-color: var(--from-color);
            will-change: background-color;
        }
        #cameraContainer {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.1s ease-out;
        }
        #heightIndicator {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 5px;
            height: 200px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            z-index: 1001;
        }
        #playerIndicator {
            position: absolute;
            right: -2.5px;
            width: 10px;
            height: 10px;
            background: #00ff00;
            border-radius: 50%;
            transform: translateY(-50%);
            transition: top 0.1s ease-out;
        }
        #player {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #1ce92d;
            bottom: 50px;
            left: 100px;
            z-index: 1000;
            transform-origin: center;
        }
        .platform {
            position: absolute;
            background: #4287f5;
            bottom: 50px;
        }
        .spike {
            position: absolute;
            bottom: 50px;
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 30px solid #ff0000;
        }
        #ground {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 50px;
            background: #333;
        }
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 48px;
            display: none;
            text-align: center;
        }
        #restartBtn {
            padding: 10px 20px;
            font-size: 18px;
            margin-top: 20px;
            cursor: pointer;
            background: #00ff00;
            border: none;
            border-radius: 5px;
        }
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #00ff00;
            border-radius: 50%;
            pointer-events: none;
        }
        
        .teleporter {
            position: absolute;
            width: 30px;
            height: 60px;
            background: linear-gradient(to right, #ff00ff, #8c00ff);
            bottom: 50px;
            border-radius: 15px;
            animation: glow 1s infinite alternate;
        }
        
        @keyframes glow {
            from { box-shadow: 0 0 5px #ff00ff; }
            to { box-shadow: 0 0 20px #ff00ff; }
        }

        /* Add level complete styling */
        #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 48px;
            display: none;
            text-align: center;
            z-index: 100;
        }

        #progressContainer {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 200px;
            color: white;
            font-size: 18px;
            text-align: left;
            z-index: 1001;
        }

        #progressBar {
            width: 100%;
            height: 10px;
            background-color: rgba(51, 51, 51, 0.5);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #progressFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #4287f5);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        /* Add tooltip styling */
        [title] {
            position: relative;
            cursor: help;
        }

        [title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 1001;
        }

        /* Loading animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Add better touch controls and responsive design */
        @media (max-width: 768px) {
            #gameContainer {
                width: 100%;
                height: 300px;
            }
        }

        #muteButton {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 20px;
            z-index: 1001;
        }

        #pauseButton {
            position: fixed;
            top: 20px;
            right: 70px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 20px;
            z-index: 1001;
        }

        #pauseMenu {
            z-index: 2000;
        }

        @keyframes backgroundTransition {
            0% { 
                background-color: var(--from-color);
            }
            100% { 
                background-color: var(--to-color);
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="cameraContainer">
            <div id="levelComplete">
                Level Complete!
                <br>
                <button id="nextLevelBtn" style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Next Level</button>
                <button onclick="window.location.href='../index.html'" style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Back to Menu</button>
            </div>
            <div id="player"></div>
            <div id="ground"></div>
        </div>
        <div id="progressContainer">
            Completion: <span id="progressText">0%</span>
            <div id="progressBar">
                <div id="progressFill"></div>
            </div>
        </div>
        <div id="heightIndicator">
            <div id="playerIndicator"></div>
        </div>
        <button id="muteButton"></button>
        <button id="pauseButton">‚è∏</button>
        <div id="gameOver">
            Game Over!
            <br>
            <button id="restartBtn">Try Again</button>
            <button onclick="window.location.href='../index.html'" style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin-top: 10px; cursor: pointer;">Back to Menu</button>
        </div>
        <div id="settingsMenu" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 20px; border-radius: 10px; color: white; text-align: center; z-index: 1000;">
            <h2>Level Settings</h2>
            
            <!-- Volume Control with tooltip -->
            <div style="margin: 20px 0;" title="Adjust the game's overall volume">
                <label for="volumeSlider">Volume: </label>
                <input type="range" id="volumeSlider" min="0" max="100" value="90" style="width: 200px;">
                <span id="volumeValue">90%</span>
            </div>

            <!-- Practice Mode with tooltip -->
            <div style="margin: 20px 0;" title="In practice mode, you won't die and can practice the level freely">
                <label for="practiceMode">Practice Mode: </label>
                <input type="checkbox" id="practiceMode" name="practiceMode">
            </div>

            <!-- Custom Controls with tooltip -->
            <div style="margin: 20px 0;" title="Choose your preferred control method">
                <label for="controlMethod">Control Method: </label>
                <select id="controlMethod" style="padding: 5px; margin-left: 10px;">
                    <option value="space">Spacebar</option>
                    <option value="click">Mouse Click</option>
                    <option value="both" selected>Both</option>
                </select>
            </div>

            <!-- Auto-Restart with tooltip -->
            <div style="margin: 20px 0;" title="Automatically restart the level when you die">
                <label for="autoRestart">Auto-Restart: </label>
                <input type="checkbox" id="autoRestart">
            </div>

            <!-- Speed Control with tooltip -->
            <div style="margin: 20px 0;" title="Adjust the game speed (Practice Mode only)">
                <label for="gameSpeed">Game Speed: </label>
                <select id="gameSpeed" style="padding: 5px; margin-left: 10px;">
                    <option value="0.5">0.5x</option>
                    <option value="1" selected>1x</option>
                    <option value="2">2x</option>
                    <option value="3">3x</option>
                </select>
            </div>

            <!-- Visual Effects with tooltip -->
            <div style="margin: 20px 0;" title="Toggle particle effects and visual enhancements">
                <label for="visualEffects">Visual Effects: </label>
                <input type="checkbox" id="visualEffects" checked>
            </div>

            <!-- Loading animation -->
            <div id="loadingAnimation" style="display: none; margin: 20px 0;">
                <div style="width: 50px; height: 50px; border: 5px solid #f3f3f3; border-top: 5px solid #00ff00; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"></div>
                <p>Preparing Level...</p>
            </div>

            <button id="startLevelBtn" style="background: #00ff00; color: black; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">
                Start Level
            </button>
        </div>
        <div id="pauseMenu" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 20px; border-radius: 10px; color: white; text-align: center; z-index: 2000;">
            <h2>Game Paused</h2>
            <button id="resumeBtn" style="background: #00ff00; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Resume</button>
            <button id="restartFromPauseBtn" style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Restart</button>
            <button onclick="window.location.href='../index.html'" style="background: #ff4444; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Exit to Menu</button>
        </div>
    </div>

    <script>
        // At the top of your script, after variable declarations
        console.log('[Line 10] Script loaded');

        // Add these debug logs right after
        console.log('[Line 13] Starting variable declarations');

        // Global level data variables
        let levelMatrix = [0];      // Stores the level layout
        let levelTitle;            // Stores the level name
        let levelMusic;            // Stores the path to level music
        let levelId;              // Stores the unique level identifier

        /**
        * Initializes level data either from a test level or from a level file
        * Returns a Promise that resolves when level data is loaded
        */
        async function initializeLevelData() {
            console.log('[Line 20] initializeLevelData called');
            return new Promise((resolve, reject) => {
                console.log('[Line 22] Inside Promise');
                if (window.location.search.includes('test=true')) {
                    console.log('[Line 24] Loading test level from editor');
                    const urlParams = new URLSearchParams(window.location.search);
                    const testData = JSON.parse(decodeURIComponent(urlParams.get('data')));
                    console.log('[Line 27] Test data:', testData);
                    
                    // Extract color row and remove it from gameplay matrix
                    const colorRow = testData.matrix[0];
                    console.log('[Line 31] Editor color row:', colorRow);
                    
                    levelMatrix = testData.matrix.slice(1);
                    levelTitle = testData.name;
                    levelMusic = testData.music;
                    levelId = testData.id;
                    document.title = levelTitle;
                    
                    // Process colors
                    colorSteps.length = 0;
                    const uniqueColors = [...new Set(colorRow)].filter(code => code < 0);
                    console.log('[Line 41] Editor unique color codes:', uniqueColors);
                    
                    uniqueColors.forEach(code => {
                        const color = COLOR_MAP[code];
                        console.log(`[Line 44] Processing editor color code ${code}:`, {
                            code: code,
                            mappedColor: color,
                            colorMap: COLOR_MAP
                        });
                        if (color) {
                            colorSteps.push(color);
                        }
                    });
                    
                    // If we only have one color, duplicate it
                    if (colorSteps.length === 1) {
                        console.log('[Line 54] Only one editor color found, duplicating for transition');
                        colorSteps.push(colorSteps[0]);
                    }
                    
                    console.log('[Line 58] Final editor color steps:', {
                        length: colorSteps.length,
                        colors: colorSteps
                    });
                    
                    // Set initial background color and start update loop
                    const gameContainer = document.getElementById('gameContainer');
                    if (gameContainer && colorSteps.length > 0) {
                        console.log('[Line 65] Setting initial editor background color:', colorSteps[0]);
                        gameContainer.style.backgroundColor = colorSteps[0];
                        // Start the game update loop
                        requestAnimationFrame(updateGame);
                    }
                    
                    resolve();
                } else {
                    console.log('[Line 26] Loading regular level');
                    const urlParams = new URLSearchParams(window.location.search);
                    const levelNumber = urlParams.get('level') || '1';  // Default to level 1 if no level specified
                    
                    console.log('[Line 29] Loading level:', levelNumber);
                    
                    // Dynamically load the level script file
                    const levelScript = document.createElement('script');
                    levelScript.src = `level${levelNumber}.js`;
                    console.log('[Line 33] Created script element for:', levelScript.src);
                    
                    levelScript.onload = () => {
                        console.log('[Line 36] Level script loaded');
                        if (window.levelData) {
                            console.log('[Line 38] Level data found:', window.levelData);
                            
                            // Extract color row and log it
                            const colorRow = window.levelData.matrix[0];
                            console.log('[Line 41] Color row:', colorRow);
                            
                            // Remove color row from gameplay matrix
                            levelMatrix = window.levelData.matrix.slice(1);
                            console.log('[Line 44] Gameplay matrix (without color row):', levelMatrix);
                            
                            // Set up color steps
                            console.log('[Line 47] Previous colorSteps:', colorSteps);
                            colorSteps.length = 0;
                            console.log('[Line 49] Cleared existing color steps');
                            
                            // Get unique color codes only
                            const uniqueColors = [...new Set(colorRow)].filter(code => code < 0);
                            console.log('[Line 52] Unique color codes:', uniqueColors);
                            
                            // Convert codes to actual colors
                            uniqueColors.forEach(code => {
                                const color = COLOR_MAP[code];
                                console.log(`[Line 56] Processing code ${code}:`, {
                                    code: code,
                                    mappedColor: color,
                                    colorMap: COLOR_MAP
                                });
                                if (color) {
                                    colorSteps.push(color);
                                }
                            });
                            
                            // If we only have one color, duplicate it to create a transition
                            if (colorSteps.length === 1) {
                                console.log('[Line 64] Only one color found, duplicating for transition');
                                colorSteps.push(colorSteps[0]);
                            }
                            
                            console.log('[Line 67] Final color steps:', {
                                length: colorSteps.length,
                                colors: colorSteps
                            });
                            
                            // Reset color transition
                            colorIndex = 0;
                            transitionFactor = 0;
                            console.log('[Line 73] Color transition reset:', {
                                colorIndex,
                                transitionFactor,
                                currentColor: colorSteps[colorIndex]
                            });
                            
                            // Set initial background color
                            const gameContainer = document.getElementById('gameContainer');
                            if (gameContainer && colorSteps.length > 0) {
                                console.log('[Line 80] Setting initial background color:', colorSteps[0]);
                                gameContainer.style.backgroundColor = colorSteps[0];
                            }
                            
                            // Set other level data
                            levelTitle = window.levelData.title;
                            levelMusic = window.levelData.music;
                            levelId = window.levelData.id;
                            document.title = levelTitle;
                            setupAudio();           // Initialize audio after level data is loaded
                            calculateTotalBlocks(); // Calculate level statistics
                            resolve();
                        } else {
                            reject('Level data not found!');
                        }
                    };
                    levelScript.onerror = () => {
                        console.error(`Failed to load level${levelNumber}.js`);
                        window.location.href = '../index.html';  // Return to menu if level file not found
                    };
                    document.body.appendChild(levelScript);
                }
            });
        }

        // Game constants to avoid magic numbers
        const CONSTANTS = {
            GRAVITY: 0.6,           // Rate at which player falls
            JUMP_FORCE: -15,        // Initial upward velocity when jumping
            BASE_GAME_SPEED: 8,     // Base movement speed of the level
            COLUMN_WIDTH: 40,       // Width of each column in the level matrix
            GROUND_HEIGHT: 50,      // Height of the ground from bottom of container
        };

        // Add these debug logs right after
        console.log('[Line 15] CONSTANTS defined:', CONSTANTS);

        // Game state variables
        let isJumping = false;              // Whether player is currently jumping
        let gravity = CONSTANTS.GRAVITY;     // Current gravity value (can be modified by power-ups)
        let jumpForce = CONSTANTS.JUMP_FORCE;// Current jump force (can be modified by power-ups)
        let playerVelocity = 0;             // Current vertical velocity of player
        let gameSpeed = CONSTANTS.BASE_GAME_SPEED; // Current game speed
        let isGameOver = false;             // Whether the game is in a "game over" state
        let rotation = 0;                   // Current rotation of the player sprite
        let obstacles = [];                 // Array of all active obstacles
        let animationFrameId = null;              // ID of the current animation frame
        let isLevelComplete = false;       // Whether the level has been completed
        let currentColumn = 0;             // Current column position in the level
        let doubleJumpAvailable = true;    // Whether double jump is available
        let particles = [];                // Array of active particle effects
        let isOnPlatform = false;         // Whether player is standing on a platform

        // Add these debug logs right after
        console.log('[Line 17] Game state variables initialized');

        // Progress tracking variables
        const progressText = document.getElementById('progressText');
        const progressFill = document.getElementById('progressFill');
        const totalColumns = levelMatrix[0].length;

        // Jump buffer timing for more responsive controls
        let jumpBufferTime = 100; // milliseconds - time window for buffering jump inputs
        let lastJumpPressTime = 0;

        // Progress update timing to optimize performance
        let lastProgressUpdate = 0;
        const progressUpdateInterval = 16; // ~60fps update frequency for progress bar
        let totalBlocks = 0;              // Total number of blocks in the level
        let passedBlocks = 0;             // Number of blocks the player has passed

        // Position of the finish line in the level matrix
        let finishLinePosition = 0;

        // Audio elements for game sounds
        let backgroundMusic = new Audio();
        let practiceMusic = new Audio('../Sound/Basic Soundeffects/practicetd.mp3');
        let jumpSound = new Audio();
        let deathSound = new Audio();
        let completionSound = new Audio();
        let isMuted = false;

        // Add these debug logs right after
        console.log('[Line 21] Audio variables initialized');

        // Game mode flags
        let isPracticeMode = false;  // Practice mode disables death
        let isLevelStarted = false;  // Whether the level has begun

        // Add these debug logs right after
        console.log('[Line 23] Game mode flags initialized');

        // Auto-restart settings
        let autoRestartEnabled = false;  // Whether to automatically restart on death
        let isRestarting = false;       // Whether the game is currently restarting

        // Add these debug logs right after
        console.log('[Line 25] Auto-restart settings initialized');

        // Pause state
        let isPaused = false;
        const pauseMenu = document.getElementById('pauseMenu');

        // Add these debug logs right after
        console.log('[Line 27] Pause state initialized');

        // Check if level complete
        const levelCompleteElement = document.getElementById('levelComplete');
        const gameOverElement = document.getElementById('gameOver');

        // Add these debug logs right after
        console.log('[Line 29] Level complete elements initialized:', {
            levelCompleteElement: !!levelCompleteElement,
            gameOverElement: !!gameOverElement
        });

        // Game state object for managing complex state
        const gameState = {
            isJumping: false,
            isPracticeMode: false,
            isGameOver: false,
            currentColumn: 0,
            // etc...
        };

        // Add these debug logs right after
        console.log('[Line 31] Game state object initialized');

        // Settings manager for persistent game settings
        const SettingsManager = {
            current: {
                volume: 90,
                practiceMode: false,
                controlMethod: 'both'
            },
            save() {
                localStorage.setItem('gameSettings', JSON.stringify(this.current));
            },
            load() {
                // Load saved settings
            }
        };

        // Add these debug logs right after
        console.log('[Line 33] Settings manager initialized');

        /**
         * Sets up audio elements with the selected music and sound effects
         * Includes error handling for failed audio loading
         */
        function setupAudio() {
            console.log('Setting up audio');
            try {
                // Initialize audio elements with proper sources
                backgroundMusic = new Audio(levelMusic);
                practiceMusic = new Audio('../Sound/Basic Soundeffects/practicetd.mp3');
                jumpSound = new Audio('../Sound/Basic Soundeffects/jumptd.mp3');
                deathSound = new Audio('../Sound/Basic Soundeffects/deathtd.ogg');
                completionSound = new Audio('../Sound/Basic Soundeffects/lvlcompletetd.mp3');

                // Set audio properties
                backgroundMusic.loop = true;
                practiceMusic.loop = true;
                
                // Set volumes
                const volumeLevel = document.getElementById('volumeSlider').value / 100;
                backgroundMusic.volume = volumeLevel * 0.6;
                practiceMusic.volume = volumeLevel * 0.6;
                jumpSound.volume = volumeLevel * 0.2;
                deathSound.volume = volumeLevel * 0.7;
                completionSound.volume = volumeLevel * 0.7;

                // Set initial mute states
                [backgroundMusic, practiceMusic, jumpSound, deathSound, completionSound].forEach(audio => {
                    audio.muted = isMuted;
                });

                console.log('Audio setup complete');
            } catch (error) {
                console.error('Audio setup failed:', error);
            }
        }

        // Add these debug logs right after
        console.log('[Line 35] About to define setupAudio function');

        // After setupAudio function
        console.log('[Line 37] setupAudio function defined');

        /**
         * Toggles the mute state of all game audio
         * Affects background music and all sound effects
         */
        function toggleMute() {
            isMuted = !isMuted;
            const currentMusic = isPracticeMode ? practiceMusic : backgroundMusic;
            
            // Mute/unmute all audio elements
            [backgroundMusic, practiceMusic, jumpSound, deathSound, completionSound].forEach(audio => {
                if (audio) audio.muted = isMuted;
            });
            
            // If unmuting, make sure the correct music is playing
            if (!isMuted) {
                if (isPracticeMode) {
                    backgroundMusic.pause();
                    practiceMusic.play().catch(e => console.error("Error playing practice music:", e));
                } else {
                    practiceMusic.pause();
                    backgroundMusic.play().catch(e => console.error("Error playing background music:", e));
                }
            }
        }

        // Add these debug logs right after
        console.log('[Line 39] About to define toggleMute function');

        // After toggleMute function
        console.log('[Line 41] toggleMute function defined');

        // Before mute button event listener
        console.log('[Line 43] About to add mute button listener');

        // Add this debug log
        console.log('[Line 44] Mute button element:', document.getElementById('muteButton'));

        // Add mute button event listener with error handling
        try {
            const muteButton = document.getElementById('muteButton');
            if (muteButton) {
                muteButton.addEventListener('click', function() {
                    toggleMute();
                    this.textContent = isMuted ? 'üîà' : 'üîä';
                });
                console.log('[Line 45] Mute button listener added successfully');
            } else {
                console.error('[Line 46] Mute button not found in DOM');
            }
        } catch (error) {
            console.error('[Line 47] Error adding mute button listener:', error);
        }

        // After mute button event listener
        console.log('[Line 48] Continuing after mute button setup');

        // Add more granular debugging
        console.log('[Line 49] About to initialize particle system');

        // Check game state
        console.log('[Line 50] Current game state:', { 
            isLevelStarted, 
            isGameOver, 
            isPaused 
        });

        // Add these new debug logs
        console.log('[Line 51] Checking game elements:', {
            gameContainer: !!document.getElementById('gameContainer'),
            player: !!document.getElementById('player')
        });

        // Initialize particles array if it doesn't exist
        if (!window.particles) {
            particles = [];
        }

        /**
         * Creates particle effects with specified color
         * @param {string} color - Color of particles (e.g., '#ff0000' for red)
         */
        function createParticles(color) {
            console.log('[Line 55] Creating particles with color:', color);
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                // Get player position relative to the game container
                const playerRect = player.getBoundingClientRect();
                const containerRect = gameContainer.getBoundingClientRect();
                
                // Calculate centered position relative to player
                const centerX = playerRect.left - containerRect.left + (playerRect.width / 2);
                const centerY = playerRect.top - containerRect.top;
                
                // Set initial particle position
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                particle.style.background = color;
                gameContainer.appendChild(particle);
                
                // Increased velocity range for more dramatic effect
                const angle = Math.random() * Math.PI * 2;
                const velocity = 8 + Math.random() * 8;
                particles.push({
                    element: particle,
                    vx: Math.cos(angle) * velocity,
                    vy: Math.sin(angle) * velocity,
                    life: 1
                });
            }
        }

        // After createParticles function definition
        console.log('[Line 54] createParticles function defined');

        // Check game state
        console.log('[Line 55] Current game state:', { 
            isLevelStarted, 
            isGameOver, 
            isPaused 
        });
        // Add these new debug logs
        console.log('[Line 56] About to check collision functions');

        // Check if required elements exist
        console.log('[Line 57] Required elements:', {
            player: !!document.getElementById('player'),
            obstacles: Array.isArray(obstacles),
            gameContainer: !!document.getElementById('gameContainer')
        });
        /**
         * Creates an obstacle based on the type specified in the level matrix
         * @param {number} type - The type of obstacle (0: empty, 1: platform, 2: spike, 3: teleporter, 4: finish)
         * @param {number} row - The row position in the level matrix
         */
        console.log('[Line 60] About to define createObstacleFromMatrix');
        function createObstacleFromMatrix(type, row) {
            // Handle empty blocks (type 0)
            if (type === 0) {
                const emptyBlock = document.createElement('div');
                emptyBlock.className = 'empty-block';
                emptyBlock.type = 'empty';
                emptyBlock.style.position = 'absolute';
                emptyBlock.style.width = '30px';
                emptyBlock.style.height = '30px';
                emptyBlock.style.left = gameContainer.offsetWidth + 'px';
                
                // Invert the row calculation to start from bottom
                const baseHeight = 50;
                const rowSpacing = 60;
                const invertedRow = (levelMatrix.length - 1) - row;
                emptyBlock.style.bottom = (baseHeight + (invertedRow * rowSpacing)) + 'px';
                
                document.getElementById('cameraContainer').appendChild(emptyBlock);
                obstacles.push({ element: emptyBlock, type: 'empty' });
                return;
            }

            // Create obstacle element based on type
            const obstacle = document.createElement('div');
            
            if (type === 4) { // Finish line
                obstacle.className = 'finishLine';
                obstacle.style.width = '10px';
                obstacle.style.height = '350px';
                obstacle.style.background = '#00ff00';
                obstacle.type = 'finish';
                obstacle.style.position = 'absolute';
                obstacle.style.bottom = '50px'; // Align with ground
            } else if (type === 2) { // Spike
                obstacle.className = 'spike';
                obstacle.type = 'spike';
            } else if (type === 3) { // Teleporter
                obstacle.className = 'teleporter';
                obstacle.type = 'teleporter';
            } else if (type === 1) { // Platform
                obstacle.className = 'platform';
                obstacle.type = 'platform';
                obstacle.style.width = '45px';
                obstacle.style.height = '45px';
            }
            
            // Position the obstacle
            obstacle.style.left = gameContainer.offsetWidth + 'px';
            
            // Calculate vertical position (inverted row calculation)
            const baseHeight = 50;
            const rowSpacing = 60;
            const invertedRow = (levelMatrix.length - 1) - row;
            obstacle.style.bottom = (baseHeight + (invertedRow * rowSpacing)) + 'px';
            
            // Add to game container and obstacles array
            document.getElementById('cameraContainer').appendChild(obstacle);
            obstacles.push({ element: obstacle, type: obstacle.type });
        }
        console.log('[Line 65] createObstacleFromMatrix defined');

        /**
         * Handles level completion state and UI
         * Called when player reaches the finish line
         */
        console.log('[Line 70] About to define levelComplete');
        function levelComplete() {
            isLevelComplete = true;
            if (levelCompleteElement) {  // Add null check
                levelCompleteElement.style.display = 'block';
            }
            
            // Play completion sound and fade music
            if (!isMuted) {
                completionSound.currentTime = 0;
                completionSound.play();
                fadeOutMusic();
            }
                    
            // Update progress indicators
            progressFill.style.width = '100%';
            progressText.textContent = '100% (Level Complete!)';
            
            // Setup next level button
            const nextLevelBtn = document.getElementById('nextLevelBtn');
            
            // Handle next level button visibility
            if (window.location.search.includes('test=true')) {
                nextLevelBtn.style.display = 'none';
            } else {
                const nextLevelNumber = parseInt(levelId) + 1;
                
                nextLevelBtn.onclick = () => {
                    window.location.href = `gameloader.html?level=${nextLevelNumber}`;
                };
                
                // Check if next level exists
                const checkScript = document.createElement('script');
                checkScript.src = `level${nextLevelNumber}.js`;
                checkScript.onload = () => {
                    nextLevelBtn.style.display = 'inline-block';
                };
                checkScript.onerror = () => {
                    nextLevelBtn.style.display = 'none';
                };
                document.body.appendChild(checkScript);
            }
                    
            cleanupParticles();
            cancelAnimationFrame(animationFrameId);
        }
        console.log('[Line 75] levelComplete defined');

        // Add camera-related variables
        let cameraOffsetY = 0;
        const CAMERA_FOLLOW_THRESHOLD = 50; // Reduced from 100 to make camera more responsive
        const MAX_CAMERA_SPEED = 20; // Increased from 15 to make camera movement smoother

        /**
         * Main game loop that updates all game elements
         * Called every animation frame when game is running
         */
        console.log('[Line 80] About to define updateGame');
        function updateGame() {
            // Don't update if game isn't in active state
            if (!isLevelStarted || isGameOver || isLevelComplete) {
                return;
            }
            
            if (isPaused) {
                requestAnimationFrame(updateGame);
                return;
            }
            
            // Update background color as part of the game loop
            updateBackgroundColor();
            
            // Apply game speed to obstacle movement
            const currentSpeed = isPracticeMode ? gameSpeed : 5;  // Default speed is 5
            
            // Create new obstacles when needed
            // Only creates obstacles when there's enough space from the last one
            if (currentColumn < levelMatrix[0].length && 
                (obstacles.length === 0 || 
                 gameContainer.offsetWidth - obstacles[obstacles.length - 1]?.element.offsetLeft > CONSTANTS.COLUMN_WIDTH)) {
                for (let row = 0; row < levelMatrix.length; row++) {
                    createObstacleFromMatrix(levelMatrix[row][currentColumn], row);
                }
                currentColumn++;
                
                // Only update progress when new obstacles are created
                updateProgress();
            }

            // Player physics calculations
            playerVelocity += gravity;
            const currentBottom = parseInt(window.getComputedStyle(player).bottom);
            let newBottom = currentBottom - playerVelocity;

            // Check ground collision with proper constants
            if (newBottom <= CONSTANTS.GROUND_HEIGHT) {
                newBottom = CONSTANTS.GROUND_HEIGHT;
                isJumping = false;
                doubleJumpAvailable = true;
                playerVelocity = 0;
            }

            // Update player position
            player.style.bottom = `${newBottom}px`;
            player.style.left = '100px'; // Keep player's horizontal position fixed

            // Rotate player during jump
            if (isJumping) {
                rotation += 5;
                player.style.transform = `rotate(${rotation}deg)`;
            } else {
                rotation = 0;
                player.style.transform = `rotate(${rotation}deg)`;
            }

            // Update obstacles with optimization
            const playerRect = player.getBoundingClientRect();
            const containerLeft = gameContainer.getBoundingClientRect().left;
            
            // Process each obstacle
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                let obstacleLeft = parseInt(obstacle.element.style.left);
                obstacle.element.style.left = (obstacleLeft - currentSpeed) + 'px';

                // Remove off-screen obstacles to improve performance
                if (obstacleLeft < -50) {
                    obstacle.element.remove();
                    obstacles.splice(i, 1);
                    continue;
                }

                // Only check collisions for nearby obstacles
                if (Math.abs(obstacleLeft - (playerRect.left - containerLeft)) < 100) {
                    const collision = checkCollision(player, obstacle.element);
                    if (collision) {
                        if (obstacle.type === 'finish') {
                            levelComplete();
                        } else if (obstacle.type === 'spike' && !isPracticeMode) {  // Check practice mode
                            gameOver();
                        } else if (obstacle.type === 'teleporter') {
                            player.style.bottom = (parseInt(player.style.bottom) + 100) + 'px';
                            playerVelocity = 0;
                            createParticles('#ff00ff'); // Purple particles on teleport
                        } else if (obstacle.type === 'platform') {
                            const platformCollision = handlePlatformCollision(playerRect, obstacle.element);
                            if (platformCollision === 'death' && !isPracticeMode) {  // Check practice mode
                                gameOver();
                            }
                        }
                    }
                }
            }

            // Update particle effects
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.vy += 0.5;  // Gravity effect on particles
                particle.life -= 0.02;  // Particle fade out
                
                // Remove dead particles
                if (particle.life <= 0) {
                    particle.element.remove();
                    particles.splice(i, 1);
                    continue;
                }
                
                // Update particle position
                const currentLeft = parseFloat(particle.element.style.left);
                const currentTop = parseFloat(particle.element.style.top);
                
                particle.element.style.left = (currentLeft + particle.vx) + 'px';
                particle.element.style.top = (currentTop + particle.vy) + 'px';
                particle.element.style.opacity = particle.life;
            }

            // Continue game loop if game is still active
            if (!isGameOver && !isLevelComplete) {
                requestAnimationFrame(updateGame);
            }

            // Update camera position to follow player
            const containerHeight = gameContainer.offsetHeight;
            const targetCameraY = Math.max(0, newBottom - containerHeight / 2);
            
            // Smooth camera movement
            const cameraDistance = targetCameraY - cameraOffsetY;
            if (Math.abs(cameraDistance) > CAMERA_FOLLOW_THRESHOLD) {
                const cameraSpeed = Math.min(Math.abs(cameraDistance) * 0.1, MAX_CAMERA_SPEED);
                cameraOffsetY += Math.sign(cameraDistance) * cameraSpeed;
            }

            // Apply camera transform
            const cameraContainer = document.getElementById('cameraContainer');
            cameraContainer.style.transform = `translateY(${cameraOffsetY}px)`;

            // Update height indicator
            const playerIndicator = document.getElementById('playerIndicator');
            const heightIndicator = document.getElementById('heightIndicator');
            const maxHeight = levelMatrix.length * 60;
            const invertedPosition = maxHeight - newBottom;
            const indicatorPosition = (invertedPosition / maxHeight) * heightIndicator.offsetHeight;
            playerIndicator.style.top = `${Math.min(heightIndicator.offsetHeight, Math.max(0, indicatorPosition))}px`;
        }
        console.log('[Line 85] updateGame defined');

        /**
         * Handles collision detection between player and obstacles
         * @param {HTMLElement} player - The player element
         * @param {HTMLElement} obstacle - The obstacle element to check collision with
         * @returns {boolean} - True if collision detected, false otherwise
         */
        console.log('[Line 90] About to define checkCollision');
        function checkCollision(player, obstacle) {
            if (obstacle.classList.contains('empty-block')) return false;
            
            // Get raw positions without camera influence
            const playerBottom = parseInt(player.style.bottom);
            const playerLeft = parseInt(player.style.left);
            const obstacleBottom = parseInt(obstacle.style.bottom);
            const obstacleLeft = parseInt(obstacle.style.left);
            
            const tolerance = 5;  // Small overlap allowance for smoother collision
            const playerSize = 30; // Player width/height
            const obstacleSize = obstacle.type === 'platform' ? 45 : 30;

            // Check for overlap in both x and y directions
            return !(playerLeft + playerSize - tolerance < obstacleLeft || 
                    playerLeft + tolerance > obstacleLeft + obstacleSize || 
                    playerBottom + playerSize - tolerance < obstacleBottom || 
                    playerBottom + tolerance > obstacleBottom + obstacleSize);
        }
        console.log('[Line 95] checkCollision defined');

        /**
         * Handles specific collision logic for platforms
         * Includes landing detection and side collision
         */
        console.log('[Line 100] About to define handlePlatformCollision');
        function handlePlatformCollision(playerRect, platform) {
            // Get raw positions without camera influence
            const playerBottom = parseInt(player.style.bottom);
            const platformBottom = parseInt(platform.style.bottom);
            const playerLeft = parseInt(player.style.left);
            const platformLeft = parseInt(platform.style.left);
            
            // Calculate overlap using absolute positions
            const horizontalOverlap = Math.min(playerLeft + 30, platformLeft + 45) - 
                                    Math.max(playerLeft, platformLeft);
            const playerWidth = 30;
            
            if (playerVelocity > 0 && // Moving downward
                playerBottom <= platformBottom + 45 && // Platform height is 45
                playerBottom >= platformBottom &&
                horizontalOverlap > playerWidth * 0.3) {
                
                // Safe landing
                isOnPlatform = true;
                isJumping = false;
                doubleJumpAvailable = true;
                playerVelocity = 0;
                player.style.bottom = (platformBottom + 45) + 'px';
                return 'safe';
            } else {
                // Side collision check
                const playerCenterX = playerLeft + (playerWidth / 2);
                const significantOverlap = horizontalOverlap > playerWidth * 0.4;
                
                if (significantOverlap && 
                    playerCenterX > platformLeft + 5 && 
                    playerCenterX < platformLeft + 40 &&
                    playerBottom > platformBottom + 15) {
                    return 'death';
                }
            }
            return 'none';
        }
        console.log('[Line 105] handlePlatformCollision defined');

        /**
         * Handles game over state and UI
         * Called when player hits spikes or collides with obstacles
         */
        console.log('[Line 110] About to define gameOver');
        function gameOver() {
            if (!isPracticeMode) {  // Only trigger game over if NOT in practice mode
                isGameOver = true;
                
                if (gameOverElement) {
                    gameOverElement.style.display = 'block';
                }
                
                if (!isMuted) {
                    if (isPracticeMode) {
                        practiceMusic.pause();
                    } else {
                        backgroundMusic.pause();
                    }
                    deathSound.currentTime = 0;
                    deathSound.play();
                }
                
                createParticles('#ff0000'); // Red particles on death
                
                if (autoRestartEnabled) {
                    setTimeout(() => {
                        restartGame();
                    }, 1000);
                } else {
                    gameOverElement.style.display = 'block';
                }
                
                cancelAnimationFrame(animationFrameId);
            } else {
                // In practice mode, just reset position but keep playing
                player.style.bottom = '50px';
                playerVelocity = 0;
                rotation = 0;
                createParticles('#ff00ff'); // Different color particles for practice mode respawn
            }
        }
        console.log('[Line 115] gameOver defined');

        /**
         * Restarts the game, resetting all necessary variables and states
         * Called after game over or when manually restarting
         */
        console.log('[Line 120] About to define restartGame');
        function restartGame() {
            // Cancel any pending animation frames
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Reset pause state
            isPaused = false;
            pauseMenu.style.display = 'none';
            
            // Reset game state
            isGameOver = false;
            isLevelComplete = false;
            currentColumn = 0;
            gameSpeed = 5;
            playerVelocity = 0;
            rotation = 0;
            isOnPlatform = false;
            
            // Reset UI elements
            if (levelCompleteElement) {  // Add null check
                levelCompleteElement.style.display = 'none';
            }
            if (gameOverElement) {  // Add null check
                gameOverElement.style.display = 'none';
            }
            player.style.bottom = '50px';
            player.style.transform = 'rotate(0deg)';

            // Clear obstacles and particles
            obstacles.forEach(obstacle => {
                if (obstacle.element && obstacle.element.parentNode) {
                    obstacle.element.remove();
                }
            });
            obstacles = [];
            
            cleanupParticles();
            
            // Reset jump state
            doubleJumpAvailable = true;
            passedBlocks = 0;
            
            // Reset progress bar
            progressFill.style.width = '0%';
            progressText.textContent = '0%';

            // Reset and replay the correct music
            if (!isMuted) {
                try {
                    if (isPracticeMode) {
                        backgroundMusic.pause();
                        practiceMusic.currentTime = 0;
                        practiceMusic.play();
                    } else {
                        practiceMusic.pause();
                        backgroundMusic.currentTime = 0;
                        backgroundMusic.play();
                    }
                } catch (error) {
                    console.error("Audio reset failed:", error);
                }
            }
            
            // Reset player position
            player.style.bottom = `${CONSTANTS.GROUND_HEIGHT}px`;
            playerVelocity = 0;
            rotation = 0;
            player.style.transform = 'rotate(0deg)';

            // Reset camera position
            cameraOffsetY = 0;
            document.getElementById('cameraContainer').style.transform = 'translateY(0)';
            
            // Start game loop
            updateGame();
        }
        console.log('[Line 125] restartGame defined');

        // Event listeners for player input
        console.log('[Line 130] About to add event listeners');
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                jump();
                e.preventDefault(); // Prevent page scrolling
            }
        });
        console.log('[Line 135] Keydown listener added');

        document.addEventListener('touchstart', jump);
        console.log('[Line 140] Touch listener added');

        restartBtn.addEventListener('click', restartGame);
        console.log('[Line 145] Restart button listener added');

        /**
         * Handles player jumping mechanics
         * Includes double jump and jump buffering
         */
        console.log('[Line 150] About to define jump');
        function jump() {
            const currentTime = Date.now();
            
            // Check if jump is allowed (not game over and either on ground or can double jump)
            if (!isGameOver && (
                (!isJumping && !isOnPlatform) || 
                (doubleJumpAvailable && currentTime - lastJumpPressTime > jumpBufferTime)
            )) {
                if (isJumping) {
                    doubleJumpAvailable = false;
                }
                isJumping = true;
                isOnPlatform = false;
                playerVelocity = jumpForce;
                
                lastJumpPressTime = currentTime;
                
                // Play jump sound if available and not muted
                if (!isMuted && jumpSound?.readyState === 4) {
                    jumpSound.currentTime = 0;
                    jumpSound.play().catch(error => console.log("Jump sound failed:", error));
                }
            }
        }
        console.log('[Line 155] jump defined');

        /**
         * Updates the progress bar and level completion percentage
         * Called from updateGame when new obstacles are created
         * Throttled to avoid performance issues
         */
        console.log('[Line 160] About to define updateProgress');
        function updateProgress() {
            // Skip updates if game is in an end state
            if (isGameOver || isLevelComplete) return;
            
            // Throttle updates based on interval
            const currentTime = Date.now();
            if (currentTime - lastProgressUpdate < progressUpdateInterval) return;
            
            // Calculate progress percentage with smoother increments
            const totalDistance = levelMatrix[0].length;
            const delayColumns = 3; // This creates our 2-second delay
            const adjustedColumn = Math.max(0, currentColumn - delayColumns);
            
            // Calculate progress with finer granularity
            const progress = (adjustedColumn / totalDistance) * 100;
            const clampedProgress = Math.min(Math.round(progress), 99); // Cap at 99% until complete
            
            // Only show 100% when level is actually complete
            const finalProgress = isLevelComplete ? 100 : 
                         progress >= 98 ? 99 : // Force 99% when near the end
                         clampedProgress;
            
            // Update UI
            progressText.textContent = `${finalProgress}%`;
            progressFill.style.width = `${finalProgress}%`;
            
            // Update progress bar colors
            if (finalProgress > 75) {
                progressFill.style.background = 'linear-gradient(90deg, #00ff00, #4287f5)';
            } else if (finalProgress > 50) {
                progressFill.style.background = 'linear-gradient(90deg, #ffff00, #00ff00)';
            } else if (finalProgress > 25) {
                progressFill.style.background = 'linear-gradient(90deg, #ffa500, #ffff00)';
            }
            
            lastProgressUpdate = currentTime;
        }
        console.log('[Line 165] updateProgress defined');

        /**
         * Calculates the total number of blocks in the level
         * Used for progress tracking and level completion
         */
        function calculateTotalBlocks() {
            // Search for finish line in level matrix
            finishLinePosition = 0;
            for (let col = 0; col < levelMatrix[0].length; col++) {
                for (let row = 0; row < levelMatrix.length; row++) {
                    if (levelMatrix[row][col] === 4) {  // 4 represents finish line
                        finishLinePosition = col;
                        break;
                    }
                }
                if (finishLinePosition > 0) break;
            }
            
            // Calculate total blocks up to finish line
            totalBlocks = finishLinePosition * levelMatrix.length;
            if (totalBlocks === 0) {
                console.error('No finish line found in level matrix!');
                totalBlocks = levelMatrix[0].length * levelMatrix.length;  // Fallback calculation
            }
        }

        // Event listener for mute button
        document.getElementById('muteButton').addEventListener('click', function() {
            toggleMute();
            this.textContent = isMuted ? 'üîà' : 'üîä';  // Update icon based on mute state
        });

        /**
         * Gradually reduces background music volume until silent
         * Used during level completion and game over
         */
        function fadeOutMusic() {
            const currentMusic = isPracticeMode ? practiceMusic : backgroundMusic;
            if (currentMusic.volume > 0.02) {
                currentMusic.volume -= 0.02;  // Reduce volume by 2%
                setTimeout(fadeOutMusic, 100);   // Check again in 100ms
            } else {
                currentMusic.pause();
                currentMusic.volume = 0.6;    // Reset volume for next time
            }
        }

        /**
         * Initializes level settings and UI controls
         * Sets up event listeners for all game settings
         */
        function initializeLevel() {
            // Get references to all UI elements
            const settingsMenu = document.getElementById('settingsMenu');
            const volumeSlider = document.getElementById('volumeSlider');
            const volumeValue = document.getElementById('volumeValue');
            const controlMethodSelect = document.getElementById('controlMethod');
            const autoRestartCheckbox = document.getElementById('autoRestart');
            const startLevelBtn = document.getElementById('startLevelBtn');
            const loadingAnimation = document.getElementById('loadingAnimation');

            // Set up volume control with real-time updates
            volumeSlider.addEventListener('input', function() {
                const volume = this.value;
                volumeValue.textContent = volume + '%';
                // Apply different volume levels to different sound types
                backgroundMusic.volume = volume / 100;
                jumpSound.volume = (volume / 100) * 0.2;      // Jump sound quieter
                deathSound.volume = (volume / 100) * 0.7;     // Death sound moderate
                completionSound.volume = (volume / 100) * 0.7; // Completion sound moderate
            });

            // Practice mode setup
            const practiceModeCheckbox = document.getElementById('practiceMode');
            if (practiceModeCheckbox) {
                console.log('Found practice mode checkbox');
                practiceModeCheckbox.addEventListener('change', function() {
                    isPracticeMode = this.checked;
                    
                    // Only switch music if the level is actually running
                    if (isLevelStarted && !isPaused && !isGameOver && !isLevelComplete) {
                        if (isPracticeMode) {
                            backgroundMusic.pause();
                            practiceMusic.currentTime = 0;
                            if (!isMuted) {
                                practiceMusic.play()
                                    .catch(error => console.error("Practice music playback failed:", error));
                            }
                        } else {
                            practiceMusic.pause();
                            backgroundMusic.currentTime = 0;
                            if (!isMuted) {
                                backgroundMusic.play()
                                    .catch(error => console.error("Normal music playback failed:", error));
                            }
                        }
                    } else {
                        // If level isn't running, make sure both music tracks are paused
                        backgroundMusic.pause();
                        practiceMusic.pause();
                    }
                });
            } else {
                console.error('Practice mode checkbox not found!');
            }

            /**
             * Configures control scheme based on user selection
             * @param {string} method - 'space', 'click', or 'both'
             */
            function setupControls(method) {
                // Clean up existing listeners to prevent duplicates
                document.removeEventListener('keydown', handleSpaceJump);
                document.removeEventListener('mousedown', jump);
                
                // Apply new control scheme
                if (method === 'space' || method === 'both') {
                    document.addEventListener('keydown', handleSpaceJump);
                }
                if (method === 'click' || method === 'both') {
                    document.addEventListener('mousedown', jump);
                }
            }

            /**
             * Handles spacebar input for jumping
             * Prevents page scrolling on space press
             */
            function handleSpaceJump(e) {
                if (e.code === 'Space') {
                    jump();
                    e.preventDefault();
                }
            }

            // Initialize with both control methods
            setupControls('both');

            // Allow user to change control method during gameplay
            controlMethodSelect.addEventListener('change', function() {
                setupControls(this.value);
            });

            // Configure auto-restart feature
            autoRestartCheckbox.addEventListener('change', function() {
                autoRestartEnabled = this.checked;
                // Persist setting in browser storage
                localStorage.setItem('autoRestartEnabled', this.checked);
            });

            // Load previously saved auto-restart preference
            const savedAutoRestart = localStorage.getItem('autoRestartEnabled');
            if (savedAutoRestart !== null) {
                autoRestartEnabled = savedAutoRestart === 'true';
                autoRestartCheckbox.checked = autoRestartEnabled;
            } 
            

            /**
             * Toggles particle effects on/off
             * Replaces particle creation function based on setting
             */
            const visualEffectsCheckbox = document.getElementById('visualEffects');
            visualEffectsCheckbox.addEventListener('change', function() {
                if (!this.checked) {
                    // Disable particles by replacing function with empty one
                    window.createParticles = function() { return; };
                } else {
                    // Restore full particle creation functionality
                    window.createParticles = function() {
                        for (let i = 0; i < 5; i++) {
                            const particle = document.createElement('div');
                            particle.className = 'particle';
                            const rect = player.getBoundingClientRect();
                            particle.style.left = (rect.left + rect.width/2) + 'px';
                            particle.style.bottom = (parseInt(player.style.bottom) || 50) + 'px';
                            gameContainer.appendChild(particle);
                            
                            // Random particle movement
                            const angle = Math.random() * Math.PI * 2;
                            const velocity = 5 + Math.random() * 5;
                            particles.push({
                                element: particle,
                                vx: Math.cos(angle) * velocity,
                                vy: Math.sin(angle) * velocity,
                                life: 1
                            });
                        }
                    };
                }
            });

            // Link practice mode with game speed control
            practiceModeCheckbox.addEventListener('change', function() {
                gameSpeedSelect.disabled = !this.checked;
                if (!this.checked) {
                    gameSpeedSelect.value = "1";
                    gameSpeed = 8; // Reset to default
                }
            });

            /**
             * Cleanup function to remove event listeners
             * Called when level is unloaded or restarted
             */
            const cleanup = () => {
                document.removeEventListener('keydown', handleSpaceJump);
                document.removeEventListener('mousedown', jump);
                document.removeEventListener('touchstart', jump);
            };
            
            // Store cleanup function for later use
            window.cleanupLevelEvents = cleanup;
        }

        /**
         * Helper function for handling jump inputs from different sources
         * @param {Event} e - The input event (keyboard or mouse)
         */
        function handleJump(e) {
            if (e.type === 'keydown' && e.code !== 'Space') return;
            jump();
        }

        /**
         * Optimized game loop using requestAnimationFrame
         * @param {number} timestamp - Current timestamp from requestAnimationFrame
         */
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            updateGame(deltaTime);
        }

        /**
         * Preloads all game assets before starting
         * Returns a Promise that resolves when all assets are loaded
         */
        async function preloadAssets() {
            await Promise.all([
                loadAudio(),
                loadImages(),
                loadLevelData()
            ]);
        }

        /**
         * Toggles game pause state and updates UI accordingly
         * Handles music pause/resume and button icons
         */
        function togglePause() {
            if (isGameOver || isLevelComplete || !isLevelStarted) return;
            
            isPaused = !isPaused;
            pauseMenu.style.display = isPaused ? 'block' : 'none';
            
            if (isPaused) {
                // Pause the appropriate music
                if (isPracticeMode) {
                    practiceMusic.pause();
                } else {
                    backgroundMusic.pause();
                }
            } else {
                // Resume the appropriate music if not muted
                if (!isMuted) {
                    if (isPracticeMode) {
                        practiceMusic.play();
                    } else {
                        backgroundMusic.play();
                    }
                }
            }
        }

        // Event listeners for pause functionality
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyP') {
                togglePause();
            }
        });

        // Resume game from pause menu
        document.getElementById('resumeBtn').addEventListener('click', togglePause);

        // Restart game from pause menu
        document.getElementById('restartFromPauseBtn').addEventListener('click', () => {
            pauseMenu.style.display = 'none';
            isPaused = false;
            restartGame();
        });

        // Toggle pause with pause button
        document.getElementById('pauseButton').addEventListener('click', togglePause);



        // Color mapping from level editor
        const COLOR_MAP = {
            '-1': '#000000',    // Default black
            '-2': '#622f62',    // Dark purple
            '-3': '#305d30',    // Dark green
            '-4': '#743a3a',    // Dark red
            '-5': '#353576'    // Dark blue
        };

        // Smooth background transition logic using the color codes
        const colorSteps = [
            COLOR_MAP['-1'],
            COLOR_MAP['-2'],
            COLOR_MAP['-3'],
            COLOR_MAP['-4'],
            COLOR_MAP['-5']
        ];
        let colorIndex = 0;
        let transitionFactor = 0;
        const totalTransitionTime = 10; // Total time for all transitions

        // Calculate transition speed and duration
        const numberOfTransitions = colorSteps.length - 1;
        const transitionDuration = totalTransitionTime / numberOfTransitions;
        const transitionSpeed = 1 / (transitionDuration * 60); // Assuming 60 frames per second

        // Add these constants near the top of your script
        const COLOR_TRANSITION = {
            DURATION: 2,    // Duration of each color transition in seconds
            SPEED: 0.0052    // Speed of transition (smaller = slower)
        };

        // Update the updateBackgroundColor function
        function updateBackgroundColor() {
            if (colorSteps.length < 2) return;
            
            // Don't proceed if we've reached the end
            if (colorIndex >= colorSteps.length - 1 && transitionFactor >= 1) {
                return;
            }

            // Update transition factor
            transitionFactor += COLOR_TRANSITION.SPEED;
            
            // When transition is complete, move to next color
            if (transitionFactor >= 1) {
                transitionFactor = 0;
                colorIndex = Math.min(colorIndex + 1, colorSteps.length - 2);
                
                console.log('[Color Transition] Moving to next color:', {
                    index: colorIndex,
                    from: colorSteps[colorIndex],
                    to: colorSteps[colorIndex + 1]
                });
            }

            const currentColor = colorSteps[colorIndex];
            const nextColor = colorSteps[colorIndex + 1];

            try {
                const newColor = interpolateColor(currentColor, nextColor, transitionFactor);
                const gameContainer = document.getElementById('gameContainer');
                if (gameContainer) {
                    gameContainer.style.backgroundColor = newColor;
                    // Remove the CSS transition to make color changes immediate
                    gameContainer.style.transition = 'none';
                }
            } catch (error) {
                console.error('[Color Transition] Error:', error);
            }
        }

        // Update the interpolateColor function for smoother transitions
        function interpolateColor(color1, color2, factor) {
            // Ensure factor is between 0 and 1
            factor = Math.max(0, Math.min(1, factor));
            
            // Parse colors
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);
            
            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);
            
            // Interpolate using cubic easing for smoother transitions
            const ease = factor * factor * (3 - 2 * factor);
            
            // Calculate new color values
            const r = Math.round(r1 + (r2 - r1) * ease);
            const g = Math.round(g1 + (g2 - g1) * ease);
            const b = Math.round(b1 + (b2 - b1) * ease);
            
            // Convert back to hex
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        /**
         * Enhanced level data validation
         * @throws {Error} If validation fails
         */
        function validateLevelData(matrix) {
            if (!matrix || !Array.isArray(matrix) || !matrix.length || !Array.isArray(matrix[0])) {
                throw new Error('Invalid level matrix format');
            }

            const width = matrix[0].length;
            let hasFinishLine = false;
            let hasValidColorCodes = false;

            // Check matrix structure and content
            for (let row = 0; row < matrix.length; row++) {
                if (matrix[row].length !== width) {
                    throw new Error('Inconsistent row lengths in matrix');
                }

                for (let col = 0; col < width; col++) {
                    const cell = matrix[row][col];
                    
                    // Top row can contain negative numbers for colors
                    if (row === 0 && cell < 0 && cell >= -5) {
                        hasValidColorCodes = true;
                        continue;
                    }
                    
                    // Other rows must contain valid obstacle codes
                    if (typeof cell !== 'number' || cell < 0 || cell > 4) {
                        throw new Error(`Invalid cell value ${cell} at position [${row},${col}]`);
                    }
                    
                    if (cell === 4) hasFinishLine = true;
                }
            }

            if (!hasFinishLine) {
                throw new Error('Level must have a finish line (type 4)');
            }

            if (!hasValidColorCodes) {
                console.warn('No background color codes found in top row');
            }
        }

        /**
         * Enhanced touch controls setup
         */
        function initializeTouchControls() {
            const touchThreshold = 20; // pixels
            let touchStartY = 0;
            let isSwiping = false;

            document.addEventListener('touchstart', function(e) {
                e.preventDefault();
                touchStartY = e.touches[0].clientY;
                isSwiping = false;
            }, { passive: false });

            document.addEventListener('touchmove', function(e) {
                if (Math.abs(e.touches[0].clientY - touchStartY) > touchThreshold) {
                    isSwiping = true;
                }
            }, { passive: false });

            document.addEventListener('touchend', function(e) {
                e.preventDefault();
                if (!isPaused && !isGameOver && !isLevelComplete && !isSwiping) {
                    jump();
                }
            }, { passive: false });
        }

        // Add cleanup function for when leaving the page
        window.addEventListener('beforeunload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
        console.log('[Line 170] All functions defined and listeners added');

        // Add this after [Line 170] All functions defined and listeners added
        console.log('[Line 171] About to add start button listener');

        // Check if button exists
        const startLevelBtn = document.getElementById('startLevelBtn');
        console.log('[Line 174] Start button element:', startLevelBtn);

        if (startLevelBtn) {
            startLevelBtn.addEventListener('click', async function() {
                console.log('[Line 177] Start button clicked');
                const loadingAnimation = document.getElementById('loadingAnimation');
                const settingsMenu = document.getElementById('settingsMenu');
                
                try {
                    // Load level data first
                    await initializeLevelData();
                    
                    // Rest of your start button code...
                    loadingAnimation.style.display = 'block';
                    this.style.display = 'none';

                    // Reset game state
                    isGameOver = false;
                    isLevelComplete = false;
                    isPaused = false;
                    currentColumn = 0;
                    playerVelocity = 0;
                    rotation = 0;
                    
                    // Clear any existing animation frame
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }

                    // Hide settings menu and start game
                    settingsMenu.style.display = 'none';
                    isLevelStarted = true;
                    
                    // Start the appropriate music
                    if (!isMuted) {
                        try {
                            if (isPracticeMode) {
                                backgroundMusic.pause();
                                await practiceMusic.play();
                            } else {
                                practiceMusic.pause();
                                await backgroundMusic.play();
                            }
                        } catch (error) {
                            console.error("Audio playback failed:", error);
                        }
                    }

                    console.log('[Line 213] Starting game loop');
                    // Start the game loop
                    requestAnimationFrame(updateGame);
                    
                } catch (error) {
                    console.error("Failed to start level:", error);
                    loadingAnimation.style.display = 'none';
                    this.style.display = 'block';
                    alert('Failed to start level. Please try again.');
                }
            });
            console.log('[Line 223] Start button listener added successfully');
        } else {
            console.error('[Line 225] Start button not found in DOM!');
        }

        console.log('[Line 228] Setup complete');

        /**
         * Cleans up all particle effects
         * Called during game restart and level completion
         */
        function cleanupParticles() {
            console.log('[Line 58] Cleaning up particles');
            // Remove all particle elements from DOM
            particles.forEach(particle => {
                if (particle.element && particle.element.parentNode) {
                    particle.element.remove();
                }
            });
            // Clear particles array
            particles = [];
            console.log('[Line 59] Particles cleanup complete');
        }

        document.addEventListener('DOMContentLoaded', function() {
            const practiceModeCheckbox = document.getElementById('practiceMode');
            if (practiceModeCheckbox) {
                console.log('Found practice mode checkbox');
                practiceModeCheckbox.addEventListener('change', function() {
                    isPracticeMode = this.checked;
                    
                    // Only switch music if the level is actually running
                    if (isLevelStarted && !isPaused && !isGameOver && !isLevelComplete) {
                        if (isPracticeMode) {
                            backgroundMusic.pause();
                            practiceMusic.currentTime = 0;
                            if (!isMuted) {
                                practiceMusic.play()
                                    .catch(error => console.error("Practice music playback failed:", error));
                            }
                        } else {
                            practiceMusic.pause();
                            backgroundMusic.currentTime = 0;
                            if (!isMuted) {
                                backgroundMusic.play()
                                    .catch(error => console.error("Normal music playback failed:", error));
                            }
                        }
                    } else {
                        // If level isn't running, make sure both music tracks are paused
                        backgroundMusic.pause();
                        practiceMusic.pause();
                    }
                });
            } else {
                console.error('Practice mode checkbox not found!');
            }
        });
    </script>
</body>
</html>
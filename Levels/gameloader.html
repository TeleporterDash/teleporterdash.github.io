<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Loading Level...</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
            transition: background-color 1s ease;
        }

        #gameContainer {
            position: relative;
            width: 1000px;
            height: 400px;
            overflow: hidden;
            perspective: 1000px;
            transition: none;
            --from-color: #000000;
            --to-color: #000000;
            background-color: var(--from-color);
            will-change: background-color;
        }

        #cameraContainer {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.1s ease-out;
        }

        #heightIndicator {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 5px;
            height: 200px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            z-index: 1001;
        }

        #playerIndicator {
            position: absolute;
            right: -2.5px;
            width: 10px;
            height: 10px;
            background: #00ff00;
            border-radius: 50%;
            transform: translateY(-50%);
            transition: top 0.1s ease-out;
        }

        #player {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #1ce92d;
            bottom: 50px;
            left: 100px;
            z-index: 1000;
            transform-origin: center;
        }

        .platform {
            position: absolute;
            background: #4287f5;
            bottom: 50px;
        }

        .spike {
            position: absolute;
            bottom: 50px;
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 30px solid #ff0000;
        }

        #ground {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 50px;
            background: #333;
        }

        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 48px;
            display: none;
            text-align: center;
        }

        #restartBtn {
            padding: 10px 20px;
            font-size: 18px;
            margin-top: 20px;
            cursor: pointer;
            background: #00ff00;
            border: none;
            border-radius: 5px;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #00ff00;
            border-radius: 50%;
            pointer-events: none;
        }

        .teleporter {
            position: absolute;
            width: 30px;
            height: 60px;
            background: linear-gradient(to right, #ff00ff, #8c00ff);
            bottom: 50px;
            border-radius: 15px;
            animation: glow 1s infinite alternate;
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 5px #ff00ff;
            }

            to {
                box-shadow: 0 0 20px #ff00ff;
            }
        }

        /* Add level complete styling */
        #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 48px;
            display: none;
            text-align: center;
            z-index: 100;
        }

        #progressContainer {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 200px;
            color: white;
            font-size: 18px;
            text-align: left;
            z-index: 1001;
        }

        #progressBar {
            width: 100%;
            height: 10px;
            background-color: rgba(51, 51, 51, 0.5);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #progressFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #4287f5);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        /* Add tooltip styling */
        [title] {
            position: relative;
            cursor: help;
        }

        [title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 1001;
        }

        /* Loading animation */
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Add better touch controls and responsive design */
        @media (max-width: 768px) {
            #gameContainer {
                width: 100%;
                height: 300px;
            }
        }

        #muteButton {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 20px;
            z-index: 1001;
        }

        #pauseButton {
            position: fixed;
            top: 20px;
            right: 70px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 20px;
            z-index: 1001;
        }

        #pauseMenu {
            z-index: 2000;
        }

        @keyframes backgroundTransition {
            0% {
                background-color: var(--from-color);
            }

            100% {
                background-color: var(--to-color);
            }
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <div id="cameraContainer">
            <div id="levelComplete">
                Level Complete!
                <br>
                <button id="nextLevelBtn"
                    style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Next
                    Level</button>
                <button onclick="window.location.href='../index.html'"
                    style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Back
                    to Menu</button>
            </div>
            <div id="player"></div>
            <div id="ground"></div>
        </div>
        <div id="progressContainer">
            Completion: <span id="progressText">0%</span>
            <div id="progressBar">
                <div id="progressFill"></div>
            </div>
        </div>
        <div id="heightIndicator">
            <div id="playerIndicator"></div>
        </div>
        <button id="muteButton"></button>
        <button id="pauseButton">‚è∏</button>
        <div id="gameOver">
            Game Over!
            <br>
            <button id="restartBtn">Try Again</button>
            <button onclick="window.location.href='../index.html'"
                style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin-top: 10px; cursor: pointer;">Back
                to Menu</button>
        </div>
        <div id="settingsMenu"
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 20px; border-radius: 10px; color: white; text-align: center; z-index: 1000;">
            <h2>Level Settings</h2>

            <!-- Volume Control with tooltip -->
            <div style="margin: 20px 0;" title="Adjust the game's overall volume">
                <label for="volumeSlider">Volume: </label>
                <input type="range" id="volumeSlider" min="0" max="100" value="90" style="width: 200px;">
                <span id="volumeValue">90%</span>
            </div>

            <!-- Practice Mode with tooltip -->
            <div style="margin: 20px 0;" title="In practice mode, you won't die and can practice the level freely">
                <label for="practiceMode">Practice Mode: </label>
                <input type="checkbox" id="practiceMode" name="practiceMode">
            </div>

            <!-- Custom Controls with tooltip -->
            <div style="margin: 20px 0;" title="Choose your preferred control method">
                <label for="controlMethod">Control Method: </label>
                <select id="controlMethod" style="padding: 5px; margin-left: 10px;">
                    <option value="space">Spacebar</option>
                    <option value="click">Mouse Click</option>
                    <option value="both" selected>Both</option>
                </select>
            </div>

            <!-- Auto-Restart with tooltip -->
            <div style="margin: 20px 0;" title="Automatically restart the level when you die">
                <label for="autoRestart">Auto-Restart: </label>
                <input type="checkbox" id="autoRestart">
            </div>

            <!-- Speed Control with tooltip -->
            <div style="margin: 20px 0;" title="Adjust the game speed (Practice Mode only)">
                <label for="gameSpeed">Game Speed: </label>
                <select id="gameSpeed" style="padding: 5px; margin-left: 10px;">
                    <option value="0.5">0.5x (Slow)</option>
                    <option value="1" selected>1x (Normal)</option>
                    <option value="1.5">1.5x (Fast)</option>
                    <option value="2">2x (Very Fast)</option>
                </select>
            </div>

            <!-- Visual Effects with tooltip -->
            <div style="margin: 20px 0;" title="Toggle particle effects and visual enhancements">
                <label for="visualEffects">Visual Effects: </label>
                <input type="checkbox" id="visualEffects" checked>
            </div>

            <!-- Loading animation -->
            <div id="loadingAnimation" style="display: none; margin: 20px 0;">
                <div
                    style="width: 50px; height: 50px; border: 5px solid #f3f3f3; border-top: 5px solid #00ff00; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;">
                </div>
                <p>Preparing Level...</p>
            </div>

            <button id="startLevelBtn"
                style="background: #00ff00; color: black; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">
                Start Level
            </button>
        </div>
        <div id="pauseMenu"
            style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 20px; border-radius: 10px; color: white; text-align: center; z-index: 2000;">
            <h2>Game Paused</h2>
            <button id="resumeBtn"
                style="background: #00ff00; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Resume</button>
            <button id="restartFromPauseBtn"
                style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Restart</button>
            <button onclick="window.location.href='../index.html'"
                style="background: #ff4444; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Exit
                to Menu</button>
        </div>
    </div>

    <script>
        // Audio helper functions
        async function safePlayAudio(audio, startTime = 0) {
            if (!audio) return;

            try {
                if (startTime !== undefined) {
                    audio.currentTime = startTime;
                }
                if (audio.readyState >= 2) {
                    await audio.play();
                } else {
                    await new Promise((resolve) => {
                        const playWhenReady = async () => {
                            await audio.play();
                            audio.removeEventListener('canplay', playWhenReady);
                            resolve();
                        };
                        audio.addEventListener('canplay', playWhenReady);
                    });
                }
            } catch (error) {
                console.error("Error playing audio:", error);
            }
        }

        async function safePauseAudio(audio) {
            if (!audio) return;
            try {
                audio.pause();
            } catch (error) {
                console.error("Error pausing audio:", error);
            }
        }

        async function switchAudioTracks(trackToPlay, trackToPause) {
            if (!trackToPlay || !trackToPause) return;
            const currentTime = trackToPause.currentTime;
            await safePauseAudio(trackToPause);
            if (!isMuted) {
                await safePlayAudio(trackToPlay, currentTime);
            }
        }

        // Global level data variables
        let levelMatrix = [0];      // Stores the level layout
        let levelTitle;            // Stores the level name
        let levelMusic;            // Stores the path to level music
        let levelId;              // Stores the unique level identifier

        const GITHUB_API_BASE = 'https://api.github.com/repos/NellowTCS/TeleporterDashLevels';
        const RAW_CONTENT_BASE = 'https://raw.githubusercontent.com/NellowTCS/TeleporterDashLevels/main';

        async function loadLevelFromGithub(filename) {
            try {
                const response = await fetch(`${RAW_CONTENT_BASE}/${filename}`);
                console.log(response);
                if (!response.ok) {
                    throw new Error('Failed to fetch level');
                }
                const levelCode = await response.text();

                // Create a safe environment to evaluate the level code
                const levelData = new Function(`
                    window = {};
                    ${levelCode}
                    return window.levelData;
                `)();

                return levelData;
            } catch (error) {
                console.error('Error loading level:', error);
                throw error;
            }
        }

        async function loadLevelFromIndexedDB(filename) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                try {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.get(filename);

                    request.onsuccess = () => {
                        if (request.result) {
                            resolve(request.result);
                        } else {
                            reject(new Error('Level not found in local storage'));
                        }
                    };

                    request.onerror = () => {
                        reject(request.error);
                    };
                } catch (error) {
                    reject(error);
                }
            });
        }

        /**
       * Initializes level data either from a test level or from a level file
       * Returns a Promise that resolves when level data is loaded
       */
        async function initializeLevelData() {
            return new Promise(async (resolve, reject) => {
                try {
                    const urlParams = new URLSearchParams(window.location.search);

                    // Test level from the editor
                    if (urlParams.has('test') && urlParams.get('test') === 'true') {
                        console.log('Loading test level from editor');
                        const testData = JSON.parse(decodeURIComponent(urlParams.get('data')));
                        await processLevelData(testData);
                        resolve();
                        return;
                    }

                    // Online levels
                    if (urlParams.has('online') && urlParams.get('online') === 'true') {
                        console.log('Loading online level');
                        const levelTitle = urlParams.get('levelFile');
                        console.log('Loading level:', levelTitle);

                        try {
                            if (!db) {
                                throw new Error('Database not initialized');
                            }

                            const level = await loadLevelFromIndexedDB(levelTitle);
                            console.log('Level loaded from IndexedDB:', level);

                            if (!level || !level.matrix) {
                                throw new Error('Invalid level data');
                            }

                            await processLevelData(level);
                            console.log('Level processed successfully');
                            resolve();
                        } catch (error) {
                            console.error('Error loading online level:', error);
                            showLoadingError(`Failed to load level: ${error.message}`);
                            reject(error);
                        }
                        return;
                    }

                    // Built-in levels
                    if (urlParams.has('level')) {
                        console.log('Loading built-in level');
                        const urlParams = new URLSearchParams(window.location.search);
                        const levelNumber = urlParams.get('level');
                        console.log('Loading level:', levelNumber);

                        // Dynamically load the level script file
                        const levelScript = document.createElement('script');
                        levelScript.src = `level${levelNumber}.js`;
                        console.log('Created script element for:', levelScript.src);

                        levelScript.onload = () => {
                            console.log('Level script loaded');
                            if (window.levelData) {
                                console.log('Level data found:', window.levelData);
                                processLevelData(window.levelData);
                            }


                        };
                        document.body.appendChild(levelScript);
                        resolve();
                    }
                } catch (error) {
                    console.error('Error initializing level data:', error);
                    showLoadingError(`Failed to initialize level: ${error.message}`);
                    reject(error);
                }
            });
        }

        async function processLevelData(data) {
            if (!data || !data.matrix) {
                throw new Error('Invalid level data: missing matrix');
            }

            // For built-in levels, first row is already the color row
            levelMatrix = data.matrix.slice(1);
            const colorRow = data.matrix[0];

            // Process colors
            colorSteps.length = 0;
            const uniqueColors = [...new Set(colorRow)].filter(code => code < 0);

            uniqueColors.forEach(code => {
                const color = COLOR_MAP[code];
                if (color) {
                    colorSteps.push(color);
                }
            });

            // If we only have one color, duplicate it
            if (colorSteps.length === 1) {
                console.log('Only one color found, duplicating it');
                colorSteps.push(colorSteps[0]);
            }

            // Reset color transition
            colorIndex = 0;
            transitionFactor = 0;

            // Set initial background color
            const gameContainer = document.getElementById('gameContainer');
            if (gameContainer && colorSteps.length > 0) {
                gameContainer.style.backgroundColor = colorSteps[0];
            }

            // Set other level data
            levelTitle = data.title || 'Untitled Level';
            levelMusic = data.music;
            levelId = data.id;
            document.title = levelTitle;

            // Initialize game systems
            setupAudio();
            calculateTotalBlocks();

            // Reset game state
            gameSpeed = 5;
            currentColumn = 0;
            playerVelocity = 0;
            rotation = 0;
            isOnPlatform = false;
            doubleJumpAvailable = true;
            passedBlocks = 0;

            // Reset progress bar
            progressFill.style.width = '0%';
            progressText.textContent = '0%';

            // Reset player position
            player.style.bottom = `${CONSTANTS.GROUND_HEIGHT}px`;
            player.style.transform = 'rotate(0deg)';

            // Reset camera position
            cameraOffsetY = 0;
            document.getElementById('cameraContainer').style.transform = 'translateY(0)';
        }

        // Game constants to avoid magic numbers
        const CONSTANTS = {
            COLUMN_WIDTH: 40,       // Width of each column in the level matrix
            GROUND_HEIGHT: 50,      // Height of the ground from bottom of container
        };


        // Game state variables
        let isJumping = false;                      // Whether player is currently jumping
        let gravity = 0.6;                          //! Rate at which player falls
        let jumpForce = -15;                        //! Initial upward velocity when jumping
        let playerVelocity = 0;                     // Current vertical velocity of player
        let gameSpeed = 5;                          //! Base movement speed of the level
        let isGameOver = false;                     // Whether the game is in a "game over" state
        let rotation = 0;                           // Current rotation of the player sprite
        let obstacles = [];                         // Array of all active obstacles
        let animationFrameId = null;                // ID of the current animation frame
        let isLevelComplete = false;                // Whether the level has been completed
        let currentColumn = 0;                      // Current column position in the level
        let doubleJumpAvailable = true;             // Whether double jump is available
        let particles = [];                         // Array of active particle effects
        let isOnPlatform = false;                   // Whether player is standing on a platform

        // Progress tracking variables
        const progressText = document.getElementById('progressText');
        const progressFill = document.getElementById('progressFill');
        const totalColumns = levelMatrix[0].length;

        // Jump buffer timing for more responsive controls
        let jumpBufferTime = 100; // milliseconds - time window for buffering jump inputs
        let lastJumpPressTime = 0;

        // Progress update timing to optimize performance
        let lastProgressUpdate = 0;
        const progressUpdateInterval = 16; // ~60fps update frequency for progress bar
        let totalBlocks = 0;              // Total number of blocks in the level
        let passedBlocks = 0;             // Number of blocks the player has passed

        // Position of the finish line in the level matrix
        let finishLinePosition = 0;

        // Audio elements for game sounds
        let backgroundMusic = new Audio();
        let practiceMusic = new Audio();
        let jumpSound = new Audio();
        let deathSound = new Audio();
        let completionSound = new Audio();
        let isMuted = false;
        let lastMusicTime = 0; // Add this at the top with other global variables

        // Game mode flags
        let isPracticeMode = false;  // Practice mode disables death
        let isLevelStarted = false;  // Whether the level has begun

        // Auto-restart settings
        let autoRestartEnabled = false;  // Whether to automatically restart on death
        let isRestarting = false;       // Whether the game is currently restarting

        // Pause state
        let isPaused = false;
        const pauseMenu = document.getElementById('pauseMenu');

        // Check if level complete
        const levelCompleteElement = document.getElementById('levelComplete');
        const gameOverElement = document.getElementById('gameOver');

        // For loading online levels
        let db;
        const DB_NAME = 'TeleporterDashDB';
        const STORE_NAME = 'downloadedLevels';
        const DB_VERSION = 2;

        // Game state object for managing complex state
        const gameState = {
            isJumping: false,
            isPracticeMode: false,
            isGameOver: false,
            currentColumn: 0,
        };

        // Settings manager for persistent game settings
        const SettingsManager = {
            current: {
                volume: 90,
                practiceMode: false,
                controlMethod: 'both',
                isMuted: false,
                autoRestartEnabled: false,
                gameSpeed: 5,
                visualEffects: true
            },
            save() {
                localStorage.setItem('gameSettings', JSON.stringify(this.current));
            },
            load() {
                const savedSettings = localStorage.getItem('gameSettings');
                if (savedSettings) {
                    const parsed = JSON.parse(savedSettings);
                    this.current = { ...this.current, ...parsed };

                    // Apply loaded settings
                    isMuted = this.current.isMuted;
                    isPracticeMode = this.current.practiceMode;
                    autoRestartEnabled = this.current.autoRestartEnabled;
                    gameSpeed = this.current.gameSpeed;

                    // Apply volume to all audio elements
                    [backgroundMusic, practiceMusic, jumpSound, deathSound, completionSound].forEach(audio => {
                        if (audio) {
                            audio.volume = this.current.volume / 100;
                            audio.muted = this.current.isMuted;
                        }
                    });

                    // Apply control method
                    setupControls(this.current.controlMethod);
                }
            }
        };

        /**
         * Sets up audio elements with the selected music and sound effects
         * Includes error handling for failed audio loading
         */
        async function setupAudio() {
            // Pause all music if playing
            await safePauseAudio(backgroundMusic);
            await safePauseAudio(practiceMusic);

            try {
                // Initialize audio elements with proper sources
                backgroundMusic = new Audio(levelMusic);
                practiceMusic = new Audio('../Sound/Basic Soundeffects/practicetd.mp3');
                jumpSound = new Audio('../Sound/Basic Soundeffects/jumptd.mp3');
                deathSound = new Audio('../Sound/Basic Soundeffects/deathtd.ogg');
                completionSound = new Audio('../Sound/Basic Soundeffects/lvlcompletetd.mp3');

                // Set audio properties
                backgroundMusic.loop = true;
                practiceMusic.loop = true;

                // Set volumes
                const volumeLevel = document.getElementById('volumeSlider').value / 100;
                backgroundMusic.volume = volumeLevel * 0.6;
                practiceMusic.volume = volumeLevel * 0.6;
                jumpSound.volume = volumeLevel * 0.2;
                deathSound.volume = volumeLevel * 0.7;
                completionSound.volume = volumeLevel * 0.7;

                // Set initial mute states
                [backgroundMusic, practiceMusic, jumpSound, deathSound, completionSound].forEach(audio => {
                    if (audio) audio.muted = isMuted;
                });

                // Create load promises for each audio element
                const loadPromises = [
                    new Promise((resolve, reject) => {
                        backgroundMusic.addEventListener('canplaythrough', resolve, { once: true });
                        backgroundMusic.addEventListener('error', reject, { once: true });
                    }),
                    new Promise((resolve, reject) => {
                        practiceMusic.addEventListener('canplaythrough', resolve, { once: true });
                        practiceMusic.addEventListener('error', reject, { once: true });
                    }),
                    new Promise((resolve, reject) => {
                        jumpSound.addEventListener('canplaythrough', resolve, { once: true });
                        jumpSound.addEventListener('error', reject, { once: true });
                    }),
                    new Promise((resolve, reject) => {
                        deathSound.addEventListener('canplaythrough', resolve, { once: true });
                        deathSound.addEventListener('error', reject, { once: true });
                    }),
                    new Promise((resolve, reject) => {
                        completionSound.addEventListener('canplaythrough', resolve, { once: true });
                        completionSound.addEventListener('error', reject, { once: true });
                    })
                ];

                // Start loading all audio files
                backgroundMusic.load();
                practiceMusic.load();
                jumpSound.load();
                deathSound.load();
                completionSound.load();

                // Wait for all audio to be ready
                await Promise.all(loadPromises);
                console.log('All audio loaded successfully');
            } catch (error) {
                console.error('Audio setup failed:', error);
                throw error;
            }
        }


        // ===== Mute or Pause Functionality =====
        /**
         * Toggles game state (mute or pause)
         * @param {string} action - Either 'mute' or 'pause'
         */
        function toggleGameState(action) {
            if (action === 'mute') {
                isMuted = !isMuted;
                SettingsManager.current.isMuted = isMuted;
                SettingsManager.save();

                // Update button appearance
                const muteButton = document.getElementById('muteButton');
                if (muteButton) {
                    const newIcon = isMuted ? 'üîá' : 'üîä';
                    muteButton.textContent = newIcon;
                }

                const currentMusic = isPracticeMode ? practiceMusic : backgroundMusic;

                if (isMuted) {
                    lastMusicTime = currentMusic.currentTime;
                    currentMusic.pause();
                } else if (isLevelStarted && !isPaused && !isGameOver && !isLevelComplete) {
                    currentMusic.currentTime = lastMusicTime;
                    currentMusic.play().catch(e => console.error("Error playing music:", e));
                }

                // Update volume for all audio elements
                [backgroundMusic, practiceMusic, jumpSound, deathSound, completionSound].forEach(audio => {
                    if (audio) {
                        audio.volume = SettingsManager.current.volume / 100;
                    }
                });
            } else if (action === 'pause') {
                if (isGameOver || isLevelComplete || !isLevelStarted) return;

                isPaused = !isPaused;
                pauseMenu.style.display = isPaused ? 'block' : 'none';

                const currentMusic = isPracticeMode ? practiceMusic : backgroundMusic;
                if (isPaused) {
                    safePauseAudio(currentMusic);
                } else {
                    // Resume from current position if not muted
                    if (!isMuted) {
                        safePlayAudio(currentMusic, currentMusic.currentTime).catch(e => console.error("Error resuming music:", e));
                    }
                }
            }
        }

        // Single mute button setup
        const muteButton = document.getElementById('muteButton');
        if (muteButton) {
            // Remove any existing listeners by cloning
            const newMuteButton = muteButton.cloneNode(true);
            muteButton.parentNode.replaceChild(newMuteButton, muteButton);

            // Add single event listener
            newMuteButton.addEventListener('click', function () {
                toggleGameState('mute');
                this.textContent = isMuted ? 'üîá' : 'üîä';
            });

            // Set initial icon
            newMuteButton.textContent = isMuted ? 'üîá' : 'üîä';
        }

        /**
         * Initializes particles array if it doesn't exist
         * @param {string} color - Color of particles (e.g., '#ff0000' for red)
         */
        function createParticles(color) {
            // Check if visual effects are enabled
            if (!SettingsManager.current.visualEffects) return;

            if (!particles) particles = [];

            // Create 10 particles
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.position = 'absolute';
                particle.style.width = '5px';
                particle.style.height = '5px';
                particle.style.backgroundColor = color;
                particle.style.left = (parseInt(player.style.left) + 15) + 'px';
                particle.style.bottom = (parseInt(player.style.bottom) + 15) + 'px';
                particle.style.borderRadius = '50%';
                particle.style.zIndex = '1000';

                gameContainer.appendChild(particle);

                const angle = (Math.random() * Math.PI * 2);
                const speed = Math.random() * 5 + 2;

                particles.push({
                    element: particle,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 2,
                    life: 1
                });
            }
        }

        /**
         * Creates an obstacle based on the type specified in the level matrix
         * @param {number} type - The type of obstacle (0: empty, 1: platform, 2: spike, 3: teleporter, 4: finish)
         * @param {number} row - The row position in the level matrix
         */
        function createObstacleFromMatrix(type, row) {
            // Handle empty blocks (type 0)
            if (type === 0) {
                const emptyBlock = document.createElement('div');
                emptyBlock.className = 'empty-block';
                emptyBlock.type = 'empty';
                emptyBlock.style.position = 'absolute';
                emptyBlock.style.width = '30px';
                emptyBlock.style.height = '30px';
                emptyBlock.style.left = gameContainer.offsetWidth + 'px';

                // Invert the row calculation to start from bottom
                const baseHeight = 50;
                const rowSpacing = 60;
                const invertedRow = (levelMatrix.length - 1) - row;
                emptyBlock.style.bottom = (baseHeight + (invertedRow * rowSpacing)) + 'px';

                document.getElementById('cameraContainer').appendChild(emptyBlock);
                obstacles.push({ element: emptyBlock, type: 'empty' });
                return;
            }

            // Create obstacle element based on type
            const obstacle = document.createElement('div');

            if (type === 4) { // Finish line
                obstacle.className = 'finishLine';
                obstacle.style.width = '10px';
                obstacle.style.height = '350px';
                obstacle.style.background = '#00ff00';
                obstacle.type = 'finish';
                obstacle.style.position = 'absolute';
                obstacle.style.bottom = '50px'; // Align with ground
            } else if (type === 2) { // Spike
                obstacle.className = 'spike';
                obstacle.type = 'spike';
            } else if (type === 3) { // Teleporter
                obstacle.className = 'teleporter';
                obstacle.type = 'teleporter';
            } else if (type === 1) { // Platform
                obstacle.className = 'platform';
                obstacle.type = 'platform';
                obstacle.style.width = '45px';
                obstacle.style.height = '45px';
            }

            // Position the obstacle
            obstacle.style.left = gameContainer.offsetWidth + 'px';

            // Calculate vertical position (inverted row calculation)
            const baseHeight = 50;
            const rowSpacing = 60;
            const invertedRow = (levelMatrix.length - 1) - row;
            obstacle.style.bottom = (baseHeight + (invertedRow * rowSpacing)) + 'px';

            // Add to game container and obstacles array
            document.getElementById('cameraContainer').appendChild(obstacle);
            obstacles.push({ element: obstacle, type: obstacle.type });
        }

        /**
         * Handles level completion state and UI
         * Called when player reaches the finish line
         */
        function levelComplete() {
            isLevelComplete = true;
            if (levelCompleteElement) {  // Add null check
                levelCompleteElement.style.display = 'block';
            }

            // Play completion sound and fade music
            if (!isMuted) {
                completionSound.currentTime = 0;
                completionSound.play();
                fadeOutMusic();
            }

            // Update progress indicators
            progressFill.style.width = '100%';
            progressText.textContent = '100% (Level Complete!)';

            // Setup next level button
            const nextLevelBtn = document.getElementById('nextLevelBtn');

            // Handle next level button visibility
            if (window.location.search.includes('test=true')) {
                nextLevelBtn.style.display = 'none';
            } else {
                const nextLevelNumber = parseInt(levelId) + 1;

                nextLevelBtn.onclick = () => {
                    window.location.href = `gameloader.html?level=${nextLevelNumber}`;
                };

                // Check if next level exists
                const checkScript = document.createElement('script');
                checkScript.src = `level${nextLevelNumber}.js`;

                checkScript.onload = () => {
                    nextLevelBtn.style.display = 'inline-block';
                };
                checkScript.onerror = () => {
                    nextLevelBtn.style.display = 'none';
                };
                document.body.appendChild(checkScript);
            }

            cleanupParticles();
            cancelAnimationFrame(animationFrameId);
        }

        // Add camera-related variables
        let cameraOffsetY = 0;
        const CAMERA_FOLLOW_THRESHOLD = 50; // Reduced from 100 to make camera more responsive
        const MAX_CAMERA_SPEED = 20; // Increased from 15 to make camera movement smoother

        /**
         * Main game loop that updates all game elements
         * Called every animation frame when game is running
         */
        function updateGame() {
            // Don't update if game isn't in active state
            if (!isLevelStarted || isGameOver || isLevelComplete) {
                return;
            }

            if (isPaused) {
                requestAnimationFrame(updateGame);
                return;
            }

            // Update background color as part of the game loop
            updateBackgroundColor();

            // Apply game speed to obstacle movement
            const baseSpeed = 5;  // Default speed
            const currentSpeed = isPracticeMode ? (baseSpeed * parseFloat(document.getElementById('gameSpeed').value)) : baseSpeed;

            // Create new obstacles when needed
            // Only creates obstacles when there's enough space from the last one
            if (currentColumn < levelMatrix[0].length &&
                (obstacles.length === 0 ||
                    gameContainer.offsetWidth - obstacles[obstacles.length - 1]?.element.offsetLeft > CONSTANTS.COLUMN_WIDTH)) {
                for (let row = 0; row < levelMatrix.length; row++) {
                    createObstacleFromMatrix(levelMatrix[row][currentColumn], row);
                }
                currentColumn++;

                // Only update progress when new obstacles are created
                updateProgress();
            }

            // Player physics calculations
            playerVelocity += gravity;
            const currentBottom = parseInt(window.getComputedStyle(player).bottom);
            let newBottom = currentBottom - playerVelocity;

            // Check ground collision with proper constants
            if (newBottom <= CONSTANTS.GROUND_HEIGHT) {
                newBottom = CONSTANTS.GROUND_HEIGHT;
                isJumping = false;
                doubleJumpAvailable = true;
                playerVelocity = 0;
            }

            // Update player position
            player.style.bottom = `${newBottom}px`;
            player.style.left = '100px'; // Keep player's horizontal position fixed

            // Rotate player during jump
            if (isJumping) {
                rotation += 5;
                player.style.transform = `rotate(${rotation}deg)`;
            } else {
                rotation = 0;
                player.style.transform = `rotate(${rotation}deg)`;
            }

            // Update obstacles with optimization
            const playerRect = player.getBoundingClientRect();
            const containerLeft = gameContainer.getBoundingClientRect().left;

            // Process each obstacle
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                let obstacleLeft = parseInt(obstacle.element.style.left);
                obstacle.element.style.left = (obstacleLeft - currentSpeed) + 'px';

                // Remove off-screen obstacles to improve performance
                if (obstacleLeft < -50) {
                    obstacle.element.remove();
                    obstacles.splice(i, 1);
                    continue;
                }

                // Only check collisions for nearby obstacles
                if (Math.abs(obstacleLeft - (playerRect.left - containerLeft)) < 100) {
                    const collision = checkCollision(player, obstacle.element);
                    if (collision) {
                        if (obstacle.type === 'finish') {
                            levelComplete();
                        } else if (obstacle.type === 'spike' && !isPracticeMode) {  // Check practice mode
                            gameOver();
                        } else if (obstacle.type === 'teleporter') {
                            player.style.bottom = (parseInt(player.style.bottom) + 120) + 'px';
                            playerVelocity = 0;
                            createParticles('#ff00ff'); // Purple particles on teleport
                        } else if (obstacle.type === 'platform') {
                            const platformCollision = handlePlatformCollision(playerRect, obstacle.element);
                            if (platformCollision === 'death' && !isPracticeMode) {  // Check practice mode
                                gameOver();
                            }
                        }
                    }
                }
            }

            // Update particle effects
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.vy += 0.5;  // Gravity effect on particles
                particle.life -= 0.02;  // Particle fade out

                // Remove dead particles
                if (particle.life <= 0) {
                    particle.element.remove();
                    particles.splice(i, 1);
                    continue;
                }

                // Update particle position
                const currentLeft = parseFloat(particle.element.style.left);
                const currentTop = parseFloat(particle.element.style.top);

                particle.element.style.left = (currentLeft + particle.vx) + 'px';
                particle.element.style.top = (currentTop + particle.vy) + 'px';
                particle.element.style.opacity = particle.life;
            }

            // Continue game loop if game is still active
            if (!isGameOver && !isLevelComplete) {
                requestAnimationFrame(updateGame);
            }

            // Update camera position to follow player
            const containerHeight = gameContainer.offsetHeight;
            const targetCameraY = Math.max(0, newBottom - containerHeight / 2);

            // Smooth camera movement
            const cameraDistance = targetCameraY - cameraOffsetY;
            if (Math.abs(cameraDistance) > CAMERA_FOLLOW_THRESHOLD) {
                const cameraSpeed = Math.min(Math.abs(cameraDistance) * 0.1, MAX_CAMERA_SPEED);
                cameraOffsetY += Math.sign(cameraDistance) * cameraSpeed;
            }

            // Apply camera transform
            const cameraContainer = document.getElementById('cameraContainer');
            cameraContainer.style.transform = `translateY(${cameraOffsetY}px)`;

            // Update height indicator
            const playerIndicator = document.getElementById('playerIndicator');
            const heightIndicator = document.getElementById('heightIndicator');
            const maxHeight = levelMatrix.length * 60;
            const invertedPosition = maxHeight - newBottom;
            const indicatorPosition = (invertedPosition / maxHeight) * heightIndicator.offsetHeight;
            playerIndicator.style.top = `${Math.min(heightIndicator.offsetHeight, Math.max(0, indicatorPosition))}px`;
        }

        /**
         * Handles collision detection between player and obstacles
         * @param {HTMLElement} player - The player element
         * @param {HTMLElement} obstacle - The obstacle element to check collision with
         * @returns {boolean} - True if collision detected, false otherwise
         */
        function checkCollision(player, obstacle) {
            if (obstacle.classList.contains('empty-block')) return false;

            // Get raw positions without camera influence
            const playerBottom = parseInt(player.style.bottom);
            const playerLeft = parseInt(player.style.left);
            const obstacleBottom = parseInt(obstacle.style.bottom);
            const obstacleLeft = parseInt(obstacle.style.left);

            const tolerance = 5;  // Small overlap allowance for smoother collision
            const playerSize = 30; // Player width/height
            const obstacleSize = obstacle.type === 'platform' ? 45 : 30;

            // Check for overlap in both x and y directions
            return !(playerLeft + playerSize - tolerance < obstacleLeft ||
                playerLeft + tolerance > obstacleLeft + obstacleSize ||
                playerBottom + playerSize - tolerance < obstacleBottom ||
                playerBottom + tolerance > obstacleBottom + obstacleSize);
        }

        /**
         * Handles specific collision logic for platforms
         * Includes landing detection and side collision
         */
        function handlePlatformCollision(playerRect, platform) {
            // Get raw positions without camera influence
            const playerBottom = parseInt(player.style.bottom);
            const platformBottom = parseInt(platform.style.bottom);
            const playerLeft = parseInt(player.style.left);
            const platformLeft = parseInt(platform.style.left);

            // Calculate overlap using absolute positions
            const horizontalOverlap = Math.min(playerLeft + 30, platformLeft + 45) -
                Math.max(playerLeft, platformLeft);
            const playerWidth = 30;

            if (playerVelocity > 0 && // Moving downward
                playerBottom <= platformBottom + 45 && // Platform height is 45
                playerBottom >= platformBottom &&
                horizontalOverlap > playerWidth * 0.3) {

                // Safe landing
                isOnPlatform = true;
                isJumping = false;
                doubleJumpAvailable = true;
                playerVelocity = 0;
                player.style.bottom = (platformBottom + 45) + 'px';
                return 'safe';
            } else {
                // Side collision check
                const playerCenterX = playerLeft + (playerWidth / 2);
                const significantOverlap = horizontalOverlap > playerWidth * 0.4;

                if (significantOverlap &&
                    playerCenterX > platformLeft + 5 &&
                    playerCenterX < platformLeft + 40 &&
                    playerBottom > platformBottom + 15) {
                    return 'death';
                }
            }
            return 'none';
        }

        /**
         * Handles game over state and UI
         * Called when player hits spikes or collides with obstacles
         */
        async function gameOver() {
            if (!isPracticeMode) {  // Only trigger game over if NOT in practice mode
                isGameOver = true;

                if (gameOverElement) {
                    gameOverElement.style.display = 'block';
                }

                // Stop all music immediately
                await Promise.all([
                    safePauseAudio(backgroundMusic),
                    safePauseAudio(practiceMusic)
                ]);

                if (!isMuted) {
                    deathSound.currentTime = 0;
                    deathSound.play();
                }

                createParticles('#ff0000'); // Red particles on death

                if (autoRestartEnabled) {
                    setTimeout(() => {
                        restartGame();
                    }, 1000);
                } else {
                    gameOverElement.style.display = 'block';
                }

                cancelAnimationFrame(animationFrameId);
            } else {
                // In practice mode, just reset position but keep playing
                player.style.bottom = '50px';
                playerVelocity = 0;
                rotation = 0;
                createParticles('#ff00ff'); // Different color particles for practice mode respawn
            }
        }

        /**
         * Restarts the game, resetting all necessary variables and states
         * Called after game over or when manually restarting
         */
        async function restartGame() {
            // Cancel any pending animation frames
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Reset pause state
            isPaused = false;
            pauseMenu.style.display = 'none';

            // Reset game state
            isGameOver = false;
            isLevelComplete = false;
            currentColumn = 0;
            gameSpeed = 5;
            playerVelocity = 0;
            rotation = 0;
            isOnPlatform = false;

            // Reset UI elements
            if (levelCompleteElement) {  // Add null check
                levelCompleteElement.style.display = 'none';
            }
            if (gameOverElement) {  // Add null check
                gameOverElement.style.display = 'none';
            }
            player.style.bottom = '50px';
            player.style.transform = 'rotate(0deg)';

            // Clear obstacles and particles
            obstacles.forEach(obstacle => {
                if (obstacle.element && obstacle.element.parentNode) {
                    obstacle.element.remove();
                }
            });
            obstacles = [];

            cleanupParticles();

            // Reset jump state
            doubleJumpAvailable = true;
            passedBlocks = 0;

            // Reset progress bar
            progressFill.style.width = '0%';
            progressText.textContent = '0%';

            // Stop all music first
            await Promise.all([
                safePauseAudio(backgroundMusic),
                safePauseAudio(practiceMusic)
            ]);

            // Start the correct music if not muted
            if (!isMuted && !isPaused) {
                try {
                    const musicToPlay = isPracticeMode ? practiceMusic : backgroundMusic;
                    const musicToPause = isPracticeMode ? backgroundMusic : practiceMusic;
                    await switchAudioTracks(musicToPlay, musicToPause);
                } catch (error) {
                    console.error("Audio reset failed:", error);
                }
            }

            // Reset player position
            player.style.bottom = `${CONSTANTS.GROUND_HEIGHT}px`;
            playerVelocity = 0;
            rotation = 0;
            player.style.transform = 'rotate(0deg)';

            // Reset camera position
            cameraOffsetY = 0;
            document.getElementById('cameraContainer').style.transform = 'translateY(0)';

            // Start game loop
            updateGame();
        }

        // ===== Event listeners for player input =====

        document.addEventListener('touchstart', jump);
        restartBtn.addEventListener('click', restartGame);

        /**
         * Handles player jumping mechanics
         * Includes double jump and jump buffering
         */
        function jump(e) {
            const currentTime = Date.now();

            // Check if jump is allowed (not game over and either on ground or can double jump)
            if (!isGameOver && (
                (!isJumping && !isOnPlatform) ||
                (doubleJumpAvailable && currentTime - lastJumpPressTime > jumpBufferTime)
            )) {
                if (isJumping) {
                    doubleJumpAvailable = false;
                }
                isJumping = true;
                isOnPlatform = false;
                playerVelocity = jumpForce;

                lastJumpPressTime = currentTime;

                // Play jump sound if available and not muted
                if (!isMuted && jumpSound?.readyState === 4) {
                    jumpSound.currentTime = 0;
                    jumpSound.play().catch(error => console.log("Jump sound failed:", error));
                }
            }
        }

        /**
         * Updates the progress bar and level completion percentage
         * Called from updateGame when new obstacles are created
         * Throttled to avoid performance issues
         */
        function updateProgress() {
            if (!levelMatrix || levelMatrix.length === 0) return;

            const currentTime = Date.now();
            if (currentTime - lastProgressUpdate < progressUpdateInterval) return;

            // Calculate progress based on current column position
            const totalColumns = levelMatrix[0].length;
            const delayColumns = 3; // Creates a 2-second delay for smoother progress
            const adjustedColumn = Math.max(0, currentColumn - delayColumns);

            // Calculate progress with finer granularity
            const progress = (adjustedColumn / totalColumns) * 100;
            const clampedProgress = Math.min(Math.round(progress), 99); // Cap at 99% until complete

            // Only show 100% when level is actually complete
            const finalProgress = isLevelComplete ? 100 :
                progress >= 98 ? 99 : // Force 99% when near the end
                    clampedProgress;

            // Update UI elements
            const progressText = document.getElementById('progressText');
            const progressFill = document.getElementById('progressFill');

            progressText.textContent = `${finalProgress}%`;
            progressFill.style.width = `${finalProgress}%`;

            // Update progress bar colors based on completion
            if (finalProgress > 75) {
                progressFill.style.background = 'linear-gradient(90deg, #00ff00, #4287f5)';
            } else if (finalProgress > 50) {
                progressFill.style.background = 'linear-gradient(90deg, #ffff00, #00ff00)';
            } else if (finalProgress > 25) {
                progressFill.style.background = 'linear-gradient(90deg, #ffa500, #ffff00)';
            }

            // Update player indicator position on height bar
            const heightIndicator = document.getElementById('heightIndicator');
            if (heightIndicator) {
                const indicatorHeight = heightIndicator.offsetHeight;
                const playerIndicator = document.getElementById('playerIndicator');
                const position = (finalProgress / 100) * indicatorHeight;
                playerIndicator.style.top = `${position}px`;
            }

            lastProgressUpdate = currentTime;
        }

        /**
         * Calculates the total number of blocks in the level
         * Used for progress tracking and level completion
         */
        function calculateTotalBlocks() {
            // Search for finish line in level matrix
            finishLinePosition = 0;
            for (let col = 0; col < levelMatrix[0].length; col++) {
                for (let row = 0; row < levelMatrix.length; row++) {
                    if (levelMatrix[row][col] === 4) {  // 4 represents finish line
                        finishLinePosition = col;
                        break;
                    }
                }
                if (finishLinePosition > 0) break;
            }

            // Calculate total blocks up to finish line
            totalBlocks = finishLinePosition * levelMatrix.length;
            if (totalBlocks === 0) {
                console.error('No finish line found in level matrix!');
                totalBlocks = levelMatrix[0].length * levelMatrix.length;  // Fallback calculation
            }
        }

        /**
         * Gradually reduces background music volume until silent
         * Used during level completion and game over
         */
        async function fadeOutMusic() {
            const currentMusic = isPracticeMode ? practiceMusic : backgroundMusic;
            while (currentMusic.volume > 0.02) {
                currentMusic.volume -= 0.02;  // Reduce volume by 2%
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            await safePauseAudio(currentMusic);
            currentMusic.volume = SettingsManager.current.volume / 100;  // Reset to user's volume setting
        }

        /**
         * Initializes level settings and UI controls
         * Sets up event listeners for all game settings
         */
        async function initializeLevel() {
            // Get references to all UI elements
            const settingsMenu = document.getElementById('settingsMenu');
            const volumeSlider = document.getElementById('volumeSlider');
            const volumeValue = document.getElementById('volumeValue');
            const controlMethodSelect = document.getElementById('controlMethod');
            const autoRestartCheckbox = document.getElementById('autoRestart');
            const practiceModeCheckbox = document.getElementById('practiceMode');
            const startLevelBtn = document.getElementById('startLevelBtn');
            const loadingAnimation = document.getElementById('loadingAnimation');

            // Load saved settings first
            SettingsManager.load();

            // Apply loaded settings to UI elements
            if (volumeSlider) {
                volumeSlider.value = SettingsManager.current.volume;
                volumeValue.textContent = SettingsManager.current.volume + '%';
            }

            if (controlMethodSelect) {
                controlMethodSelect.value = SettingsManager.current.controlMethod;
            }

            if (practiceModeCheckbox) {
                practiceModeCheckbox.checked = SettingsManager.current.practiceMode;
                isPracticeMode = SettingsManager.current.practiceMode;
            }

            if (autoRestartCheckbox) {
                autoRestartCheckbox.checked = SettingsManager.current.autoRestartEnabled;
                autoRestartEnabled = SettingsManager.current.autoRestartEnabled;
            }

            // Visual effects setup
            const visualEffectsCheckbox = document.getElementById('visualEffects');
            if (visualEffectsCheckbox) {
                visualEffectsCheckbox.checked = SettingsManager.current.visualEffects;
                visualEffectsCheckbox.addEventListener('change', function () {
                    SettingsManager.current.visualEffects = this.checked;
                    SettingsManager.save();
                });
            }

            // Set up volume control with real-time updates
            if (volumeSlider) {
                volumeSlider.addEventListener('input', function () {
                    const volume = this.value;
                    volumeValue.textContent = volume + '%';

                    // Update settings
                    SettingsManager.current.volume = volume;
                    SettingsManager.save();

                    // Apply volume to all audio elements
                    [backgroundMusic, practiceMusic, jumpSound, deathSound, completionSound].forEach(audio => {
                        if (audio) {
                            audio.volume = SettingsManager.current.volume / 100;
                        }
                    });
                });
            }

            // Practice mode setup
            if (practiceModeCheckbox) {
                practiceModeCheckbox.addEventListener('change', async function () {
                    isPracticeMode = this.checked;
                    SettingsManager.current.practiceMode = isPracticeMode;
                    SettingsManager.save();

                    // Enable/disable game speed control
                    const gameSpeedSelect = document.getElementById('gameSpeed');
                    if (gameSpeedSelect) {
                        gameSpeedSelect.disabled = !isPracticeMode;
                        if (!isPracticeMode) {
                            gameSpeed = 5;
                            gameSpeedSelect.value = "1";
                            SettingsManager.current.gameSpeed = gameSpeed;
                            SettingsManager.save();
                        }
                    }

                    // Only switch music if the level is actually running
                    if (isLevelStarted && !isPaused && !isGameOver && !isLevelComplete) {
                        try {
                            const musicToPlay = isPracticeMode ? practiceMusic : backgroundMusic;
                            const musicToPause = isPracticeMode ? backgroundMusic : practiceMusic;
                            await switchAudioTracks(musicToPlay, musicToPause);
                        } catch (error) {
                            console.error("Error switching music tracks:", error);
                        }
                    } else {
                        // If level isn't running, make sure both music tracks are paused
                        await Promise.all([
                            safePauseAudio(backgroundMusic),
                            safePauseAudio(practiceMusic)
                        ]);
                    }
                });
            }

            // Game speed setup
            const gameSpeedSelect = document.getElementById('gameSpeed');
            if (gameSpeedSelect) {
                // Initialize game speed select state
                gameSpeedSelect.disabled = !isPracticeMode;
                if (SettingsManager.current.gameSpeed) {
                    gameSpeed = SettingsManager.current.gameSpeed;
                    gameSpeedSelect.value = gameSpeed.toString();
                }

                gameSpeedSelect.addEventListener('change', function () {
                    if (isPracticeMode) {
                        const newSpeed = parseFloat(this.value);
                        gameSpeed = newSpeed;
                        SettingsManager.current.gameSpeed = newSpeed;
                        SettingsManager.save();
                    }
                });
            }

            // Control method setup
            if (controlMethodSelect) {
                controlMethodSelect.addEventListener('change', function () {
                    const method = this.value;
                    SettingsManager.current.controlMethod = method;
                    SettingsManager.save();
                    setupControls(method);
                });
            }
        }

        /**
         * Configures control scheme based on user selection
         * @param {string} method - 'space', 'click', or 'both'
         */
        function setupControls(method) {
            // Remove all existing event listeners first
            document.removeEventListener('keydown', handleSpaceJump);
            document.removeEventListener('mousedown', handleMouseJump);
            document.removeEventListener('keydown', (e) => {
                if (e.code === 'Space') jump();
            });

            // Apply new control scheme
            if (method === 'space') {
                document.addEventListener('keydown', handleSpaceJump);
            } else if (method === 'click') {
                document.addEventListener('mousedown', handleMouseJump);
            } else if (method === 'both') {
                document.addEventListener('keydown', handleSpaceJump);
                document.addEventListener('mousedown', handleMouseJump);
            }
        }

        /**
         * Handles spacebar input for jumping
         * Prevents page scrolling on space press
         */
        function handleSpaceJump(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                jump();
            }
        }

        /**
         * Handles mouse input for jumping
         */
        function handleMouseJump(e) {
            if (e.button === 0) { // Left click only
                jump();
            }
        }

        /**
         * Optimized game loop using requestAnimationFrame
         * @param {number} timestamp - Current timestamp from requestAnimationFrame
         */
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            updateGame(deltaTime);
        }

        /**
         * Preloads all game assets before starting
         * Returns a Promise that resolves when all assets are loaded
         */
        async function preloadAssets() {
            await Promise.all([
                loadAudio(),
                loadImages(),
                loadLevelData()
            ]);
        }

        /**
         * Toggles game pause state and updates UI accordingly
         * Handles music pause/resume and button icons
         */
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyP') {
                toggleGameState('pause');
            }
        });

        // Resume game from pause menu
        document.getElementById('resumeBtn').addEventListener('click', () => toggleGameState('pause'));

        // Restart game from pause menu
        document.getElementById('restartFromPauseBtn').addEventListener('click', () => {
            pauseMenu.style.display = 'none';
            isPaused = false;
            restartGame();
        });

        // Toggle pause with pause button
        document.getElementById('pauseButton').addEventListener('click', () => toggleGameState('pause'));

        // Escape key handler
        document.addEventListener('keydown', (e) => {
            if (e.key === "Escape") {
                toggleGameState('pause');
            }
        });

        // Color mapping from level editor
        const COLOR_MAP = {
            '-1': '#000000',    // Default black
            '-2': '#622f62',    // Dark purple
            '-3': '#305d30',    // Dark green
            '-4': '#743a3a',    // Dark red
            '-5': '#353576'    // Dark blue
        };

        // Smooth background transition logic using the color codes
        const colorSteps = [
            COLOR_MAP['-1'],
            COLOR_MAP['-2'],
            COLOR_MAP['-3'],
            COLOR_MAP['-4'],
            COLOR_MAP['-5']
        ];
        let colorIndex = 0;
        let transitionFactor = 0;
        const totalTransitionTime = 10; // Total time for all transitions

        // Calculate transition speed and duration
        const numberOfTransitions = colorSteps.length - 1;
        const transitionDuration = totalTransitionTime / numberOfTransitions;
        const transitionSpeed = 1 / (transitionDuration * 60); // Assuming 60 frames per second

        // Add these constants near the top of your script
        const COLOR_TRANSITION = {
            DURATION: 2,    // Duration of each color transition in seconds
            SPEED: 0.0052    // Speed of transition (smaller = slower)
        };

        // Update the updateBackgroundColor function
        function updateBackgroundColor() {
            if (colorSteps.length < 2) return;

            // Don't proceed if we've reached the end
            if (colorIndex >= colorSteps.length - 1 && transitionFactor >= 1) {
                return;
            }

            // Update transition factor
            transitionFactor += COLOR_TRANSITION.SPEED;

            // When transition is complete, move to next color
            if (transitionFactor >= 1) {
                transitionFactor = 0;
                colorIndex = Math.min(colorIndex + 1, colorSteps.length - 2);
            }

            const currentColor = colorSteps[colorIndex];
            const nextColor = colorSteps[colorIndex + 1];

            try {
                const newColor = interpolateColor(currentColor, nextColor, transitionFactor);
                const gameContainer = document.getElementById('gameContainer');
                if (gameContainer) {
                    gameContainer.style.backgroundColor = newColor;
                    // Remove the CSS transition to make color changes immediate
                    gameContainer.style.transition = 'none';
                }
            } catch (error) {
                console.error('[Color Transition] Error:', error);
            }
        }

        // Update the interpolateColor function for smoother transitions
        function interpolateColor(color1, color2, factor) {
            // Ensure factor is between 0 and 1
            factor = Math.max(0, Math.min(1, factor));

            // Parse colors
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);

            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);

            // Interpolate using cubic easing for smoother transitions
            const ease = factor * factor * (3 - 2 * factor);

            // Calculate new color values
            const r = Math.round(r1 + (r2 - r1) * ease);
            const g = Math.round(g1 + (g2 - g1) * ease);
            const b = Math.round(b1 + (b2 - b1) * ease);

            // Convert back to hex
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        /**
         * Enhanced level data validation
         * @throws {Error} If validation fails
         */
        function validateLevelData(matrix) {
            if (!matrix || !Array.isArray(matrix) || !matrix.length || !Array.isArray(matrix[0])) {
                throw new Error('Invalid level matrix format');
            }

            const width = matrix[0].length;
            let hasFinishLine = false;
            let hasValidColorCodes = false;

            // Check matrix structure and content
            for (let row = 0; row < matrix.length; row++) {
                if (matrix[row].length !== width) {
                    throw new Error('Inconsistent row lengths in matrix');
                }

                for (let col = 0; col < width; col++) {
                    const cell = matrix[row][col];

                    // Top row can contain negative numbers for colors
                    if (row === 0 && cell < 0 && cell >= -5) {
                        hasValidColorCodes = true;
                        continue;
                    }

                    // Other rows must contain valid obstacle codes
                    if (typeof cell !== 'number' || cell < 0 || cell > 4) {
                        throw new Error(`Invalid cell value ${cell} at position [${row},${col}]`);
                    }

                    if (cell === 4) hasFinishLine = true;
                }
            }

            if (!hasFinishLine) {
                throw new Error('Level must have a finish line (type 4)');
            }

            if (!hasValidColorCodes) {
                console.warn('No background color codes found in top row');
            }
        }

        /**
         * Enhanced touch controls setup
         */
        function initializeTouchControls() {
            const touchThreshold = 20; // pixels
            let touchStartY = 0;
            let isSwiping = false;

            document.addEventListener('touchstart', function (e) {
                e.preventDefault();
                touchStartY = e.touches[0].clientY;
                isSwiping = false;
            }, { passive: false });

            document.addEventListener('touchmove', function (e) {
                if (Math.abs(e.touches[0].clientY - touchStartY) > touchThreshold) {
                    isSwiping = true;
                }
            }, { passive: false });

            document.addEventListener('touchend', function (e) {
                e.preventDefault();
                if (!isPaused && !isGameOver && !isLevelComplete && !isSwiping) {
                    jump();
                }
            }, { passive: false });
        }

        // Add cleanup function for when leaving the page
        window.addEventListener('beforeunload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
        console.log('All functions defined and listeners added');

        // Check if button exists
        const startLevelBtn = document.getElementById('startLevelBtn');

        if (startLevelBtn) {
            startLevelBtn.addEventListener('click', async function () {
                const loadingAnimation = document.getElementById('loadingAnimation');
                const settingsMenu = document.getElementById('settingsMenu');

                try {
                    // Load level data first
                    await initializeLevelData();

                    // Rest of your start button code...
                    loadingAnimation.style.display = 'block';
                    this.style.display = 'none';

                    // Reset game state
                    isGameOver = false;
                    isLevelComplete = false;
                    isPaused = false;
                    currentColumn = 0;
                    playerVelocity = 0;
                    rotation = 0;

                    // Clear any existing animation frame
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }

                    // Hide settings menu and start game
                    settingsMenu.style.display = 'none';

                    // Reset game state before starting
                    gameSpeed = 5;
                    currentColumn = 0;
                    playerVelocity = 0;
                    rotation = 0;
                    isOnPlatform = false;
                    doubleJumpAvailable = true;

                    // Setup audio and wait for it to be ready
                    await setupAudio();

                    // Start the appropriate music
                    if (!isMuted) {
                        try {
                            const musicToPlay = isPracticeMode ? practiceMusic : backgroundMusic;
                            const musicToPause = isPracticeMode ? backgroundMusic : practiceMusic;
                            await switchAudioTracks(musicToPlay, musicToPause);
                        } catch (error) {
                            console.error("Error playing music:", error);
                        }
                    }

                    isLevelStarted = true;


                    // Reset animation frame if it exists
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }

                    // Start the game loop
                    requestAnimationFrame(updateGame);

                } catch (error) {
                    console.error("Failed to start level:", error);
                    loadingAnimation.style.display = 'none';
                    this.style.display = 'block';
                    alert('Failed to start level. Please try again.');
                }
            });
        } else {
            console.error('Start button not found in DOM!');
        }

        /**
         * Cleans up all particle effects
         * Called during game restart and level completion
         */
        function cleanupParticles() {
            // Remove all particle elements from DOM
            particles.forEach(particle => {
                if (particle.element && particle.element.parentNode) {
                    particle.element.remove();
                }
            });
            // Clear particles array
            particles = [];
        }


        // Initialize IndexedDB
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => {
                    console.error('Failed to open database:', request.error);
                    reject(request.error);
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('Database opened successfully');
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'filename' });
                        console.log('Object store created');
                    }
                };
            });
        }

        async function loadLevelFromIndexedDB(filename) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                try {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.get(filename);

                    request.onsuccess = () => {
                        if (request.result) {
                            resolve(request.result);
                        } else {
                            reject(new Error('Level not found in local storage'));
                        }
                    };

                    request.onerror = () => {
                        reject(request.error);
                    };
                } catch (error) {
                    reject(error);
                }
            });
        }

        // Initialize database when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // Load settings first
                SettingsManager.load();

                // Initialize database
                await initDB();

                // Initialize level data
                await initializeLevelData();

                // Initialize UI and controls
                await initializeLevel();

                // Set up audio
                await setupAudio();

                // Start game loop
                requestAnimationFrame(gameLoop);

            } catch (error) {
                console.error('Error during initialization:', error);
                showLoadingError('Failed to initialize game. Please try again.');
            }
        });
    </script>
</body>

</html>
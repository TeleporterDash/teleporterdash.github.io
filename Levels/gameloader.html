<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Loading Level...</title>
    <script src="../Modules/scoreManager.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
            font-family: 'Orbitron', sans-serif;
            transition: background-color 1s ease;
            touch-action: manipulation;
        }

        #gameContainer {
            position: relative;
            width: calc(100% - 80px);
            max-width: 1000px;
            height: calc(100% - 60px);
            min-height: 460px;
            margin: 0 auto;
            overflow: hidden;
            perspective: 1000px;
            transition: none;
            --from-color: #000000;
            --to-color: #000000;
            background-color: var(--from-color);
            will-change: background-color;
        }

        #cameraContainer {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.1s ease-out;
        }

        #player {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #1ce92d;
            bottom: 50px;
            left: 100px;
            z-index: 1000;
            transform-origin: center;
        }

        .platform {
            position: absolute;
            background: #4287f5;
            bottom: 50px;
        }

        .spike {
            position: absolute;
            bottom: 50px;
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 30px solid #ff0000;
        }

        #ground {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 50px;
            background: #333;
        }

        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 48px;
            display: none;
            text-align: center;
        }

        #restartBtn {
            padding: 10px 20px;
            font-size: 18px;
            margin-top: 20px;
            cursor: pointer;
            background: #00ff00;
            border: none;
            border-radius: 5px;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #00ff00;
            border-radius: 50%;
            pointer-events: none;
        }

        .teleporter {
            position: absolute;
            width: 30px;
            height: 60px;
            background: linear-gradient(to right, #ff00ff, #8c00ff);
            bottom: 50px;
            border-radius: 15px;
            animation: glow 1s infinite alternate;
        }

        .teleporter::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 12px solid white;
            pointer-events: none;
        }

        .teleporter[data-rotation="90"]::after {
            border: none;
            border-bottom: 12px solid white;
            border-right: 8px solid transparent;
            border-left: 8px solid transparent;
        }

        .teleporter[data-rotation="180"]::after {
            border-top: none;
            border-bottom: 12px solid white;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
        }

        .teleporter[data-rotation="270"]::after {
            border: none;
            border-bottom: 12px solid white;
            border-right: 8px solid transparent;
            border-left: 8px solid transparent;
        }

        /* Rotation classes for teleporter */

        @keyframes glow {
            from {
                box-shadow: 0 0 5px #ff00ff;
            }

            to {
                box-shadow: 0 0 20px #ff00ff;
            }
        }

        #levelComplete {
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, 0);
            transform-style: preserve-3d;
            perspective: none;
            background: rgba(0, 0, 0, 0.475);
            color: #00ff00;
            font-size: 48px;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 9999;
            display: none;
        }

        #progressContainer {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 200px;
            color: white;
            font-size: 18px;
            text-align: left;
            z-index: 1001;
        }

        #progressBar {
            width: 100%;
            height: 10px;
            background-color: rgba(51, 51, 51, 0.5);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #progressFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #4287f5);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        /* Add tooltip styling */
        [title] {
            position: relative;
            cursor: help;
        }

        [title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.475);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 1001;
        }

        /* Loading animation */
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Add better touch controls and responsive design */
        @media (max-width: 768px) {
            #gameContainer {
                width: 100%;
                height: 300px;
            }
        }

        #muteButton {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 20px;
            z-index: 1001;
        }

        #pauseButton {
            position: fixed;
            top: 20px;
            right: 70px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 20px;
            z-index: 1001;
        }

        #pauseMenu {
            z-index: 2000;
        }

        @keyframes backgroundTransition {
            0% {
                background-color: var(--from-color);
            }

            100% {
                background-color: var(--to-color);
            }
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <div id="cameraContainer">
            
            <div id="player"></div>
            <div id="ground"></div>
        </div>
        <div id="progressContainer">
            Completion: <span id="progressText">0%</span>
            <div id="progressBar">
                <div id="progressFill"></div>
            </div>
        </div>
        <button id="muteButton"></button>
        <button id="pauseButton">‚è∏</button>
        <div id="timer" style="position: fixed; top: 10px; left: 230px; background: rgba(0, 0, 0, 0.3); color: #00ff00; padding: 10px; border-radius: 5px; font-family: 'Orbitron', sans-serif; font-size: 24px; z-index: 1000;">0:00</div>
        <div id="gameOver">
            Game Over!
            <br>
            <button id="restartBtn">Try Again</button>
            <button onclick="window.location.href='../TDMenu.html'"
                style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin-top: 10px; cursor: pointer;">Back
                to Menu</button>
        </div>
        <div id="settingsMenu"
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.6); padding: 20px; border-radius: 10px; color: white; text-align: center; z-index: 1000;">
            <h2>Level Settings</h2>

            <!-- Volume Control with tooltip -->
            <div style="margin: 20px 0;" title="Adjust the game's overall volume">
                <label for="volumeSlider">Volume: </label>
                <input type="range" id="volumeSlider" min="0" max="100" value="90" style="width: 200px;">
                <span id="volumeValue">90%</span>
            </div>

            <!-- Practice Mode with tooltip -->
            <div style="margin: 20px 0;" title="In practice mode, you won't die and can practice the level freely">
                <label for="practiceMode">Practice Mode: </label>
                <input type="checkbox" id="practiceMode" name="practiceMode">
            </div>

            <!-- Custom Controls with tooltip -->
            <div style="margin: 20px 0;" title="Choose your preferred control method">
                <label for="controlMethod">Control Method: </label>
                <select id="controlMethod" style="padding: 5px; margin-left: 10px;">
                    <option value="space">Spacebar</option>
                    <option value="click">Mouse Click</option>
                    <option value="both" selected>Both</option>
                </select>
            </div>

            <!-- Auto-Restart with tooltip -->
            <div style="margin: 20px 0;" title="Automatically restart the level when you die">
                <label for="autoRestart">Auto-Restart: </label>
                <input type="checkbox" id="autoRestart">
            </div>

            <!-- Speed Control with tooltip -->
            <div style="margin: 20px 0;" title="Adjust the game speed (Practice Mode only)">
                <label for="gameSpeed">Game Speed: </label>
                <select id="gameSpeed" style="padding: 5px; margin-left: 10px;">
                    <option value="0.5">0.5x (Slow)</option>
                    <option value="1" selected>1x (Normal)</option>
                    <option value="1.5">1.5x (Fast)</option>
                    <option value="2">2x (Very Fast)</option>
                </select>
            </div>

            <!-- Visual Effects with tooltip -->
            <div style="margin: 20px 0;" title="Toggle particle effects and visual enhancements">
                <label for="visualEffects">Visual Effects: </label>
                <input type="checkbox" id="visualEffects" checked>
            </div>

            <!-- Loading animation -->
            <div id="loadingAnimation" style="display: none; margin: 20px 0;">
                <div
                    style="width: 50px; height: 50px; border: 5px solid #f3f3f3; border-top: 5px solid #00ff00; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;">
                </div>
                <p>Preparing Level...</p>
            </div>

            <button id="startLevelBtn"
                style="background: #00ff00; color: black; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">
                Start Level
            </button>
        </div>
        <div id="pauseMenu"
            style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.475); padding: 20px; border-radius: 10px; color: white; text-align: center; z-index: 2000;">
            <h2>Game Paused</h2>
            <button id="resumeBtn"
                style="background: #00ff00; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Resume</button>
            <button id="restartFromPauseBtn"
                style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Restart</button>
            <button onclick="window.location.href='../TDMenu.html'"
                style="background: #ff4444; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Exit
                to Menu</button>
        </div>
    </div>
    <div id="levelComplete">
        Level Complete!
        <br>
        <button id="nextLevelBtn"
            style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Next
            Level</button>
        <button onclick="window.location.href='../TDMenu.html'"
            style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Back
            to Menu</button>
    </div>

    <script>
        // Score tracking variables
        let jumpCount = 0;
        let deathCount = 0;
        let startTime = 0;
        let currentTime = 0;
        let levelTimer = null;
        let levelTime = 0;  // Track elapsed time in seconds

        // ===== Audio Manager =====
        const AudioManager = {
                // // "Initialize" Variables
            backgroundMusic: null,
            practiceMusic: null,
            jumpSound: null,
            deathSound: null,
            completionSound: null,
            isMuted: false,
            lastMusicTime: 0,
            isInitialized: false,

                // // Play
            async play(audio, startTime = 0) {
                if (!audio) return;
                try {
                    await audio.play();
                    // Set time after starting playback to avoid reset
                    if (startTime !== undefined && startTime > 0) {
                        audio.currentTime = startTime;
                    }
                } catch (error) {
                    console.error("Error playing audio:", error);
                }
            },

                // // Pause
            async pause(audio) {
                if (!audio) return;
                try {
                    audio.pause();
                } catch (error) {
                    console.error("Error pausing audio:", error);
                }
            },

                // // Switch Audio
            async switchTracks(trackToPlay, trackToPause) {
                if (!trackToPlay || !trackToPause) return;
                const currentTime = trackToPause.currentTime;
                await this.pause(trackToPause);
                if (!this.isMuted) {
                    await this.play(trackToPlay, currentTime);
                }
            },

                // // Initialize Audio
            async initialize(levelMusicPath) {
                if (this.isInitialized) {
                    // If already initialized, just update the background music source
                    await this.pause(this.backgroundMusic);
                    this.backgroundMusic = new Audio(levelMusicPath);
                    this.backgroundMusic.loop = true;
                    return;
                }

                // Initialize all audio elements
                this.backgroundMusic = new Audio(levelMusicPath);
                this.practiceMusic = new Audio('../Sound/Basic Soundeffects/practicetd.ogg');
                this.jumpSound = new Audio('../Sound/Basic Soundeffects/jumptd.ogg');
                this.deathSound = new Audio('../Sound/Basic Soundeffects/deathtd.ogg');
                this.completionSound = new Audio('../Sound/Basic Soundeffects/lvlcompletetd.ogg');

                this.isInitialized = true;
            },

                // // Setup/Update Audio
            async setup(levelMusicPath) {
                // Initialize or update audio elements
                await this.initialize(levelMusicPath);

                try {
                    // Set audio properties
                    this.backgroundMusic.loop = true;
                    this.practiceMusic.loop = true;

                    // Set volumes
                    const volumeLevel = document.getElementById('volumeSlider').value / 100;
                    this.backgroundMusic.volume = volumeLevel * 0.6;
                    this.practiceMusic.volume = volumeLevel * 0.6;
                    this.jumpSound.volume = volumeLevel * 0.2;
                    this.deathSound.volume = volumeLevel * 0.7;
                    this.completionSound.volume = volumeLevel * 0.7;

                    // Set initial mute states
                    [this.backgroundMusic, this.practiceMusic, this.jumpSound, this.deathSound, this.completionSound].forEach(audio => {
                        if (audio) audio.muted = this.isMuted;
                    });

                    // Create load promises for each audio element
                    const loadPromises = [
                        this.createLoadPromise(this.backgroundMusic),
                        this.createLoadPromise(this.practiceMusic),
                        this.createLoadPromise(this.jumpSound),
                        this.createLoadPromise(this.deathSound),
                        this.createLoadPromise(this.completionSound)
                    ];

                    // Start loading all audio files
                    this.backgroundMusic.load();
                    this.practiceMusic.load();
                    this.jumpSound.load();
                    this.deathSound.load();
                    this.completionSound.load();

                    // Wait for all audio to be ready
                    await Promise.all(loadPromises);
                    console.log('All audio loaded successfully');
                } catch (error) {
                    console.error('Audio setup failed:', error);
                    throw error;
                }
            },
 
                // // Event Listener
            async restart() {
                if (this.backgroundMusic) {
                    this.backgroundMusic.currentTime = 0;
                    if (!this.isMuted) {
                        try {
                            await this.play(this.backgroundMusic);
                        } catch (error) {
                            console.error('Failed to restart audio:', error);
                        }
                    }
                }
            },

            createLoadPromise(audio) {
                return new Promise((resolve, reject) => {
                    audio.addEventListener('canplaythrough', resolve, { once: true });
                    audio.addEventListener('error', reject, { once: true });
                });
            },

                // // Fade Out Audio at Level Completion
            async fadeOut(audio, duration = 1000) {
                if (!audio || audio.paused) return;

                const startVolume = audio.volume;
                const steps = 20;
                const stepTime = duration / steps;
                const volumeStep = startVolume / steps;

                for (let i = steps; i > 0; i--) {
                    audio.volume = volumeStep * i;
                    await new Promise(resolve => setTimeout(resolve, stepTime));
                }

                await this.pause(audio);
                audio.volume = startVolume;
            },

                // // Mute
            toggleMute() {
                this.isMuted = !this.isMuted;
                SettingsManager.current.isMuted = this.isMuted;
                SettingsManager.save();

                const currentMusic = isPracticeMode ? this.practiceMusic : this.backgroundMusic;

                if (this.isMuted) {
                    this.lastMusicTime = currentMusic.currentTime;
                    this.pause(currentMusic);
                } else if (isLevelStarted && !isPaused && !isGameOver && !isLevelComplete) {
                    // Don't set currentTime before play, let play handle it
                    this.play(currentMusic, this.lastMusicTime).catch(e => console.error("Error playing music:", e));
                }

                // Update volume for all audio elements
                [this.backgroundMusic, this.practiceMusic, this.jumpSound, this.deathSound, this.completionSound].forEach(audio => {
                    if (audio) {
                        audio.volume = SettingsManager.current.volume / 100;
                    }
                });
            }
        };

        // Global level data variables
        let levelMatrix = [0];      // Stores the level layout
        let levelColorRow = [];     // Stores the color information
        let levelTitle;            // Stores the level name
        let levelMusic;            // Stores the path to level music
        let levelId;              // Stores the unique level identifier
        let isLevelStarted = false;
        let isPracticeMode = false;
        let gameContainer = document.getElementById('gameContainer');  // Game container element

        // Color mapping for blocks
        const COLOR_MAP = {
            '0': '#000000',  // Black
            '-1': '#ff6b6b',  // Red
            '-2': '#4ecdc4',  // Cyan
            '-3': '#45b7d1',  // Blue
            '-4': '#96ceb4',  // Green
            '-5': '#ff9f1c',  // Orange
            '-6': '#ffbe0b',  // Yellow
            '-7': '#ff006e',  // Pink
            '-8': '#8338ec',  // Purple
            '-9': '#3a86ff'   // Light Blue
        };

        // ===== Level Loader =====
        const LevelLoader = {
                // // "Initialize" Variables
            db: null,
            DB_NAME: 'TeleporterDashDB',
            STORE_NAME: 'downloadedLevels',
            DB_VERSION: 2,
            GITHUB_API_BASE: 'https://api.github.com/repos/NellowTCS/TeleporterDashLevels',
            RAW_CONTENT_BASE: 'https://raw.githubusercontent.com/NellowTCS/TeleporterDashLevels/main',


                // // Load from Github
            async loadFromGithub(filename) {
                try {
                    const response = await fetch(`${this.RAW_CONTENT_BASE}/${filename}`);
                    if (!response.ok) {
                        throw new Error('Failed to fetch level');
                    }
                    const levelCode = await response.text();

                    // Create a safe environment to evaluate the level code
                    const levelData = new Function(`
                        window = {};
                        ${levelCode}
                        return window.levelData;
                    `)();

                    return levelData;
                } catch (error) {
                    console.error('Error loading level:', error);
                    throw error;
                }
            },

                // // Load from IndexedDB
            async loadFromIndexedDB(filename) {
                return new Promise((resolve, reject) => {
                    if (!this.db) {
                        reject(new Error('Database not initialized'));
                        return;
                    }

                    try {
                        const transaction = this.db.transaction([this.STORE_NAME], 'readonly');
                        const store = transaction.objectStore(this.STORE_NAME);
                        const request = store.get(filename);

                        request.onsuccess = () => {
                            if (request.result) {
                                resolve(request.result);
                            } else {
                                reject(new Error('Level not found in local storage'));
                            }
                        };

                        request.onerror = () => {
                            reject(request.error);
                        };
                    } catch (error) {
                        reject(error);
                    }
                });
            },

                // // Load Test Level
            async loadTestLevel() {
                const dbName = 'LevelEditorDB';
                const testStore = 'testLevel';

                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(dbName, 1);

                    request.onerror = () => reject(new Error('Failed to open database'));

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(testStore)) {
                            db.createObjectStore(testStore, { keyPath: 'currentTest' });
                        }
                    };

                    request.onsuccess = (event) => {
                        const db = event.target.result;
                        const transaction = db.transaction([testStore], 'readonly');
                        const store = transaction.objectStore(testStore);
                        const getRequest = store.get('currentTest');

                        getRequest.onsuccess = () => {
                            const testData = getRequest.result;
                            if (testData) {
                                resolve({
                                    matrix: testData.matrix,
                                    title: 'Test Level',
                                    author: testData.author,
                                    difficulty: testData.difficulty,
                                    musicValue: testData.musicValue,
                                    musicData: testData.musicData,
                                    id: 'test',
                                    colorTransitionDuration: 2.0,
                                    colorTransitionDelay: 0.2
                                });
                            } else {
                                reject(new Error('No test level found'));
                            }
                        };

                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains(testStore)) {
                                db.createObjectStore(testStore, { keyPath: 'currentTest' });
                            }
                        };

                        getRequest.onerror = () => reject(new Error('Failed to load test level'));
                    };
                });
            },

                // // Initialize Database
            async initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
            
                    request.onerror = () => {
                        console.error("Database error:", request.error);
                        reject(new Error('Failed to open database'));
                    };
            
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log("Database opened successfully");
                        resolve(this.db);
                    };
            
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(this.STORE_NAME)) {
                            db.createObjectStore(this.STORE_NAME);
                            console.log("Object store created");
                        }
                        if (!db.objectStoreNames.contains('scores')) {
                            db.createObjectStore('scores');
                            console.log("Scores object store created");
                        }
                    };
                });
            },

                // // Initialize Level Data
            async initializeLevelData() {
                try {
                    const urlParams = new URLSearchParams(window.location.search);

                    // Test level from the editor
                    if (urlParams.has('test') && urlParams.get('test') === 'true') {
                        console.log('Loading test level from editor');
                        const testData = await this.loadTestLevel();
                        await this.processLevelData(testData);
                        requestAnimationFrame(updateGame);
                        if (isPracticeMode) {
                            this.initializePracticeMode();
                        }
                        return;
                    }

                    // Online levels
                    if (urlParams.has('online') && urlParams.get('online') === 'true') {
                        console.log('Loading online level');
                        const levelTitle = urlParams.get('levelFile');
                        console.log('Loading level:', levelTitle);

                        try {
                            if (!this.db) {
                                throw new Error('Database not initialized');
                            }

                            const level = await this.loadFromIndexedDB(levelTitle);
                            console.log('Level loaded from IndexedDB:', level);

                            if (!level || !level.matrix) {
                                throw new Error('Invalid level data');
                            }

                            await this.processLevelData(level);
                            console.log('Level processed successfully');
                        } catch (error) {
                            console.error('Error loading online level:', error);
                            showLoadingError(`Failed to load level: ${error.message}`);
                            throw error;
                        }
                        return;
                    }

                    // Built-in levels
                    if (urlParams.has('level')) {
                        console.log('Loading built-in level');
                        const levelNumber = urlParams.get('level');
                        console.log('Loading level:', levelNumber);

                        // Dynamically load the level script file
                        const levelScript = document.createElement('script');
                        levelScript.src = `level${levelNumber}.js`;
                        console.log('Created script element for:', levelScript.src);

                        await new Promise((resolve, reject) => {
                            levelScript.onload = () => {
                                console.log('Level script loaded');
                                if (window.levelData) {
                                    console.log('Level data found:', window.levelData);
                                    this.processLevelData(window.levelData)
                                        .then(() => {
                                            requestAnimationFrame(updateGame);
                                            if (isPracticeMode) {
                                                this.initializePracticeMode();
                                            }
                                            resolve();
                                        })
                                        .catch(reject);
                                } else {
                                    reject(new Error('Level data not found in loaded script'));
                                }
                            };

                            levelScript.onerror = (error) => {
                                console.error('Error loading level script:', error);
                                showLoadingError(`Failed to load level ${levelNumber}`);
                                reject(error);
                            };

                            document.body.appendChild(levelScript);
                        });
                    }
                } catch (error) {
                    console.error('Error initializing level data:', error);
                    showLoadingError(`Failed to initialize level: ${error.message}`);
                    throw error;
                }
            },

                // // Process Level Data
            async processLevelData(data) {
                if (!data || !data.matrix) {
                    throw new Error('Invalid level data: missing matrix');
                }

                // For built-in levels, first row is already the color row
                levelMatrix = data.matrix.slice(1);
                levelColorRow = data.matrix[0];  // Store color row separately

                // Process colors
                colorSteps.length = 0;
                const uniqueColors = [...new Set(levelColorRow)].filter(code => {
                    // Handle both simple color codes and block properties
                    if (typeof code === 'string') {
                        const props = code.split('/');
                        return props.some(p => p.startsWith('-'));
                    }
                    return code < 0;
                }).map(code => {
                    // Extract color from block properties if needed
                    if (typeof code === 'string') {
                        const props = code.split('/');
                        const colorProp = props.find(p => p.startsWith('-'));
                        return parseInt(colorProp);
                    }
                    return code;
                });

                uniqueColors.forEach(code => {
                    const color = COLOR_MAP[code];
                    if (color) {
                        colorSteps.push(color);
                    }
                });

                // If we only have one color, duplicate it
                if (colorSteps.length === 1) {
                    console.log('Only one color found, duplicating it');
                    colorSteps.push(colorSteps[0]);
                }

                // Reset color transition
                colorIndex = 0;
                transitionFactor = 0;

                // Set initial background color
                const gameContainer = document.getElementById('gameContainer');
                if (gameContainer && colorSteps.length > 0) {
                    gameContainer.style.backgroundColor = colorSteps[0];
                }

                // Set other level data
                levelTitle = data.title || 'Untitled Level';
                levelAuthor = data.author || 'Unknown Author';
                levelDifficulty = data.difficulty || 'Normal';

                // Handle music data
                if (data.musicValue === 'custom' && data.musicData) {
                    const blob = new Blob([data.musicData.data], { type: data.musicData.type });
                    levelMusic = URL.createObjectURL(blob);
                } else if (isPracticeMode) {
                    levelMusic = '../Sound/Basic Soundeffects/practicetd.ogg';
                } else if (data.musicValue && data.musicValue.startsWith('../Sound/Level Soundtracks/')) {
                    levelMusic = `${data.musicValue}`;
                    console.log("Level Soundtrack: ", levelMusic);
                } else if (data.musicValue) {
                    levelMusic = `../Sound/Level Soundtracks/${data.musicValue}`;
                    console.log("Level Soundtrack: ", levelMusic);
                } else if (data.musicData) {
                    levelMusic = `${data.musicData}`;
                    console.log("Level Soundtrack: ", levelMusic);
                } else if (data.music && data.music.startsWith('../Sound/Level Soundtracks/')) {
                    levelMusic = `${data.music}`;
                    console.log("Level Soundtrack: ", levelMusic);
                } else if (data.music) {
                    levelMusic = `../Sound/Level Soundtracks/${data.music}`;
                    console.log("Level Soundtrack: ", levelMusic);
                } else {
                    levelMusic = '../Sound/Level Soundtracks/level1.ogg';
                    console.log("Using default soundtrack");
                }

                levelId = data.id;
                document.title = levelTitle;

                // Initialize audio with the new level music
                await AudioManager.setup(levelMusic);

                // Initialize game systems
                requestAnimationFrame(updateGame);
                calculateTotalBlocks();

                // Reset game state
                gameSpeed = 5;
                currentColumn = 0;
                playerVelocity = 0;
                rotation = 0;
                isOnPlatform = false;
                doubleJumpAvailable = true;
                passedBlocks = 0;

                // Reset progress bar
                progressFill.style.width = '0%';
                progressText.textContent = '0%';

                // Reset player position
                player.style.bottom = `${CONSTANTS.GROUND_HEIGHT}px`;
                player.style.transform = 'rotate(0deg)';

                // Reset camera position
                cameraOffsetY = 0;
            },
            // // Initialize Practice Mode
            initializePracticeMode() {
                const gameSpeedSelect = document.getElementById('gameSpeed');
                if (gameSpeedSelect) {
                    gameSpeedSelect.disabled = false;
                    if (SettingsManager.current.gameSpeed) {
                        gameSpeed = SettingsManager.current.gameSpeed;
                        gameSpeedSelect.value = gameSpeed.toString();
                    }
                }

                // Switch to practice mode music
                if (isLevelStarted && !isPaused && !isGameOver && !isLevelComplete) {
                    try {
                        AudioManager.switchTracks(AudioManager.practiceMusic, AudioManager.backgroundMusic);
                    } catch (error) {
                        console.error("Error switching to practice mode music:", error);
                    }
                }
            }
        };

        // Initialize database when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                console.log('Starting ScoreManager initialization...');
                await ScoreManager.initialize().catch(error => {
                    console.error('ScoreManager initialization failed:', error);
                    throw error;
                });
                console.log('ScoreManager initialized successfully');

                // Only update UI if initialization succeeded
                if (levelId) {
                    ScoreManager.updateScoreboardUI(levelId);
                }

                // Then proceed with level loading
                console.log('Starting level initialization...');
                await LevelLoader.initDB();
                await LevelLoader.initializeLevelData();
                await initializeLevel();
                console.log('Level initialization complete');
            } catch (error) {
                console.error('Error during initialization:', error);
                showLoadingError(`Failed to initialize: ${error.message}`);
            }
        });

        // ===== Variables =====
        const CONSTANTS = {
            COLUMN_WIDTH: 40,       // Width of each column in the level matrix
            GROUND_HEIGHT: 50,      // Height of the ground from bottom of container
            INITIAL_SPACE: 740,     // Initial empty space before level starts (IMP)
        };


            // // Game state variables
        let isJumping = false;                      // Whether player is currently jumping
        let gravity = 0.6;                          //! Rate at which player falls
        let jumpForce = -15;                        //! Initial upward velocity when jumping
        let playerVelocity = 0;                     // Current vertical velocity of player
        let gameSpeed = 5;                          //! Base movement speed of the level
        let isGameOver = false;                     // Whether the game is in a "game over" state
        let rotation = 0;                           // Current rotation of the player sprite
        let obstacles = [];                         // Array of all active obstacles
        let animationFrameId = null;                // ID of the current animation frame
        let isLevelComplete = false;                // Whether the level has been completed
        let currentColumn = 0;                      // Current column position in the level
        let doubleJumpAvailable = true;             // Whether double jump is available
        let particles = [];                         // Array of active particle effects
        let isOnPlatform = false;                   // Whether player is standing on a platform

        // Progress tracking variables
        const progressText = document.getElementById('progressText');
        const progressFill = document.getElementById('progressFill');
        const totalColumns = levelMatrix[0].length;

        // Jump buffer timing for more responsive controls
        let jumpBufferTime = 100; // milliseconds - time window for buffering jump inputs
        let lastJumpPressTime = 0;

        // Progress update timing to optimize performance
        let lastProgressUpdate = 0;
        const progressUpdateInterval = 16; // ~60fps update frequency for progress bar
        let totalBlocks = 0;              // Total number of blocks in the level
        let passedBlocks = 0;             // Number of blocks the player has passed

        // Position of the finish line in the level matrix
        let finishLinePosition = 0;

        // Auto-restart settings
        let autoRestartEnabled = false;  // Whether to automatically restart on death
        let isRestarting = false;       // Whether the game is currently restarting

        // Pause state
        let isPaused = false;
        const pauseMenu = document.getElementById('pauseMenu');

        // Check if level complete
        const levelCompleteElement = document.getElementById('levelComplete');
        const gameOverElement = document.getElementById('gameOver');

        // For loading online levels
        let db;
        const DB_NAME = 'TeleporterDashDB';
        const STORE_NAME = 'downloadedLevels';
        const DB_VERSION = 2;

        // Game state object for managing complex state
        const gameState = {
            isJumping: false,
            isPracticeMode: false,
            isGameOver: false,
            currentColumn: 0,
        };

        // ===== Level Settings =====
        // Settings manager for persistent game settings
        const SettingsManager = {
            current: {
                volume: 90,
                practiceMode: false,
                controlMethod: 'both',
                isMuted: false,
                autoRestartEnabled: false,
                gameSpeed: 5,
                visualEffects: true
            },
            save() {
                localStorage.setItem('gameSettings', JSON.stringify(this.current));
            },
            load() {
                const savedSettings = localStorage.getItem('gameSettings');
                if (savedSettings) {
                    const parsed = JSON.parse(savedSettings);
                    this.current = { ...this.current, ...parsed };

                    // Apply loaded settings
                    isMuted = this.current.isMuted;
                    isPracticeMode = this.current.practiceMode;
                    autoRestartEnabled = this.current.autoRestartEnabled;
                    gameSpeed = this.current.gameSpeed;

                    // Apply volume to all audio elements
                    [AudioManager.backgroundMusic, AudioManager.practiceMusic, AudioManager.jumpSound, AudioManager.deathSound, AudioManager.completionSound].forEach(audio => {
                        if (audio) {
                            audio.volume = this.current.volume / 100;
                            audio.muted = this.current.isMuted;
                        }
                    });

                    // Apply control method
                    setupControls(this.current.controlMethod);
                }
            }
        };

        /**
         * Toggles game state (mute or pause)
         * @param {string} action - Either 'mute' or 'pause'
         */
        function toggleGameState(action) {
            if (action === 'mute') {
                AudioManager.toggleMute();
            } else if (action === 'pause') {
                if (isGameOver || isLevelComplete || !isLevelStarted) return;

                isPaused = !isPaused;
                pauseMenu.style.display = isPaused ? 'block' : 'none';

                const currentMusic = isPracticeMode ? AudioManager.practiceMusic : AudioManager.backgroundMusic;
                if (isPaused) {
                    AudioManager.pause(currentMusic);
                } else {
                    // Resume from current position if not muted
                    if (!AudioManager.isMuted) {
                        AudioManager.play(currentMusic, currentMusic.currentTime).catch(e => console.error("Error resuming music:", e));
                    }
                }
            }
        }

        // Single mute button setup
        const muteButton = document.getElementById('muteButton');
        if (muteButton) {
            // Remove any existing listeners by cloning
            const newMuteButton = muteButton.cloneNode(true);
            muteButton.parentNode.replaceChild(newMuteButton, muteButton);

            // Add single event listener
            newMuteButton.addEventListener('click', function () {
                toggleGameState('mute');
                this.textContent = AudioManager.isMuted ? 'üîá' : 'üîä';
            });

            // Set initial icon
            newMuteButton.textContent = AudioManager.isMuted ? 'üîá' : 'üîä';
        }

        /**
         * Initializes particles array if it doesn't exist
         * @param {string} color - Color of particles (e.g., '#ff0000' for red)
         */
        function createParticles(color) {
            // Check if visual effects are enabled
            if (!SettingsManager.current.visualEffects) return;

            if (!particles) particles = [];

            // Create 10 particles
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.position = 'absolute';
                particle.style.width = '5px';
                particle.style.height = '5px';
                particle.style.backgroundColor = color;
                particle.style.left = (parseInt(player.style.left) + 15) + 'px';
                particle.style.bottom = (parseInt(player.style.bottom) + 15) + 'px';
                particle.style.borderRadius = '50%';
                particle.style.zIndex = '1000';

                gameContainer.appendChild(particle);

                const angle = (Math.random() * Math.PI * 2);
                const speed = Math.random() * 5 + 2;

                particles.push({
                    element: particle,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 2,
                    life: 1
                });
            }
        }

        /**
         * Creates an obstacle based on the type specified in the level matrix
         * @param {number} type - The type of obstacle (0: empty, 1: platform, 2: spike, 3: teleporter, 4: finish)
         * @param {number} row - The row position in the level matrix
         */
        function createObstacleFromMatrix(type, row) {
            // Parse block properties if type is a string (contains properties)
            let blockType = type;
            let blockColor = null;
            let blockRotation = 0;

            if (typeof type === 'string') {
                const properties = type.split('/');
                // First property is always the type
                blockType = parseInt(properties[0]);

                // Process other properties
                for (let i = 1; i < properties.length; i++) {
                    const prop = properties[i];
                    if (prop.startsWith('-')) {
                        // Color property (negative number)
                        blockColor = COLOR_MAP[parseInt(prop)];
                    } else if (prop.startsWith('@')) {
                        // Rotation property
                        blockRotation = parseInt(prop.substring(1));
                    }
                }
            }

            // Handle empty blocks (type 0)
            if (blockType === 0) {
                const emptyBlock = document.createElement('div');
                emptyBlock.className = 'empty-block';
                emptyBlock.type = 'empty';
                emptyBlock.style.position = 'absolute';
                emptyBlock.style.width = '30px';
                emptyBlock.style.height = '30px';
                emptyBlock.style.left = gameContainer.offsetWidth + 'px';

                // Invert the row calculation to start from bottom
                const baseHeight = 50;
                const rowSpacing = 45; // Match platform block height
                const invertedRow = (levelMatrix.length - 1) - row;
                emptyBlock.style.bottom = (baseHeight + (invertedRow * rowSpacing)) + 'px';

                document.getElementById('cameraContainer').appendChild(emptyBlock);
                obstacles.push({ element: emptyBlock, type: 'empty' });
                return;
            }

            // Create obstacle element based on type
            const obstacle = document.createElement('div');

            if (blockType === 4) { // Finish line
                obstacle.className = 'finishLine';
                obstacle.style.width = '10px';
                obstacle.style.height = '350px';
                obstacle.style.background = '#00ff00';
                obstacle.type = 'finish';
                obstacle.style.position = 'absolute';
                obstacle.style.bottom = '50px'; // Align with ground
            } else if (blockType === 2) { // Spike
                obstacle.className = 'spike';
                obstacle.type = 'spike';
            } else if (blockType === 3) { // Teleporter
                obstacle.className = 'teleporter';
                obstacle.type = 'teleporter';
                obstacle.style.width = '30px';
                obstacle.style.height = '60px';
                obstacle.style.background = 'linear-gradient(to right, #ff00ff, #8c00ff)';
                obstacle.style.borderRadius = '15px';
                obstacle.style.animation = 'glow 1s infinite alternate';

                // Extract rotation if it exists
                if (typeof type === 'string' && type.includes('@')) {
                    const rotation = type.split('@')[1];
                    obstacle.setAttribute('data-rotation', rotation);
                }
            } else if (blockType === 1) { // Platform
                obstacle.className = 'platform';
                obstacle.type = 'platform';
                obstacle.style.width = '45px';
                obstacle.style.height = '45px';
            }

            // Apply color if specified
            if (blockColor) {
                if (blockType === 2) { // For spikes
                    obstacle.style.borderBottomColor = blockColor;
                } else {
                    obstacle.style.backgroundColor = blockColor;
                }
            }

            // Apply rotation if specified
            if (blockRotation !== 0) {
                obstacle.style.transform = `rotate(${blockRotation}deg)`;
            }

            // Position the obstacle
            obstacle.style.left = gameContainer.offsetWidth + 'px';

            // Calculate vertical position (inverted row calculation)
            const baseHeight = 50;
            const rowSpacing = 45; // Match platform block height
            const invertedRow = (levelMatrix.length - 1) - row;
            obstacle.style.bottom = (baseHeight + (invertedRow * rowSpacing)) + 'px';

            document.getElementById('cameraContainer').appendChild(obstacle);
            obstacles.push({ element: obstacle, type: obstacle.type });
        }

        /**
         * Handles collision detection between player and obstacles
         * @param {HTMLElement} player - The player element
         * @param {HTMLElement} obstacle - The obstacle element to check collision with
         * @returns {boolean} - True if collision detected, false otherwise
         */
        function checkCollision(player, obstacle) {
            if (obstacle.classList.contains('empty-block')) return false;

            // Get raw positions without camera influence
            const playerBottom = parseInt(player.style.bottom);
            const playerLeft = parseInt(player.style.left);
            const obstacleBottom = parseInt(obstacle.style.bottom);
            const obstacleLeft = parseInt(obstacle.style.left);

            const tolerance = 5;  // Small overlap allowance for smoother collision
            const playerSize = 30; // Player width/height
            const obstacleSize = obstacle.type === 'platform' ? 45 : 30;

            // Get obstacle rotation
            let rotation = 0;
            const transform = obstacle.style.transform;
            if (transform) {
                const match = transform.match(/rotate\((\d+)deg\)/);
                if (match) {
                    rotation = parseInt(match[1]);
                }
            }

            // Adjust collision box based on rotation for spikes
            let adjustedObstacleBottom = obstacleBottom;
            let adjustedObstacleLeft = obstacleLeft;

            if (obstacle.type === 'spike') {
                switch (rotation) {
                    case 90:  // Pointing left
                        adjustedObstacleLeft += obstacleSize / 2;
                        break;
                    case 180:  // Pointing up
                        adjustedObstacleBottom += obstacleSize / 2;
                        break;
                    case 270:  // Pointing right
                        adjustedObstacleLeft -= obstacleSize / 2;
                        break;
                    default:  // Pointing down or no rotation
                        adjustedObstacleBottom -= obstacleSize / 2;
                }
            }

            // Check for overlap in both x and y directions
            return !(playerLeft + playerSize - tolerance < adjustedObstacleLeft ||
                playerLeft + tolerance > adjustedObstacleLeft + obstacleSize ||
                playerBottom + playerSize - tolerance < adjustedObstacleBottom ||
                playerBottom + tolerance > adjustedObstacleBottom + obstacleSize);
        }

        /**
         * Handles specific collision logic for platforms
         * Includes landing detection and side collision
         */
        function handlePlatformCollision(playerRect, platform) {
            // Get raw positions without camera influence
            const playerBottom = parseInt(player.style.bottom);
            const platformBottom = parseInt(platform.style.bottom);
            const playerLeft = parseInt(player.style.left);
            const platformLeft = parseInt(platform.style.left);

            // Calculate overlaps
            const horizontalOverlap = Math.min(playerLeft + 30, platformLeft + 40) -
                Math.max(playerLeft, platformLeft);
            const verticalOverlap = Math.min(playerBottom + 30, platformBottom + 40) -
                Math.max(playerBottom, platformBottom);
            
            const playerWidth = 30;
            const horizontalCollision = horizontalOverlap / playerWidth;

            // First, check for side collision - this takes priority
            // If we have any meaningful horizontal collision and we're not jumping, it's death
            if (horizontalCollision > 0.2 && // Significant horizontal collision
                verticalOverlap > 5 && // Some vertical overlap
                !isJumping && // Not in a jump
                Math.abs(playerBottom - (platformBottom + 40)) > 15) { // Not very close to top
                return 'death';
            }

            // Only then check for safe landing
            if (playerVelocity > 0 && // Moving down
                Math.abs(playerBottom - (platformBottom + 40)) < 10 && // Very close to top
                horizontalCollision > 0.3) { // Enough horizontal overlap for landing
                
                // Safe landing
                isOnPlatform = true;
                isJumping = false;
                doubleJumpAvailable = true;
                playerVelocity = 0;
                player.style.bottom = (platformBottom + 45) + 'px';
                return 'safe';
            }
            
            return 'none';
        }

        /**
         * Handles level completion state and UI
         * Called when player reaches the finish line
         */
        function levelComplete() {  
            isLevelComplete = true;
            clearInterval(levelTimer);
        
            // Save score using the filename instead of levelId
            const urlParams = new URLSearchParams(window.location.search);
            const onlineparam = urlParams.get('online');
            if (onlineparam) {
                const filename = urlParams.get('levelFile');
                ScoreManager.addRun(filename, levelTime, jumpCount, deathCount);
            } else {
                const filename = urlParams.get('level');
                ScoreManager.addRun('Level ' + filename, levelTime, jumpCount, deathCount);
            }
        
            

            if (levelCompleteElement) {  // Add null check
                levelCompleteElement.style.display = 'block';
            }

            // Play completion sound and fade music
            if (!AudioManager.isMuted) {
                AudioManager.completionSound.currentTime = 0;
                AudioManager.completionSound.play();
                AudioManager.fadeOut(isPracticeMode ? AudioManager.practiceMusic : AudioManager.backgroundMusic);
            }

            // Update progress indicators
            progressFill.style.width = '100%';
            progressText.textContent = '100% (Level Complete!)';

            // Setup next level button
            const nextLevelBtn = document.getElementById('nextLevelBtn');

            // Handle next level button visibility
            if (window.location.search.includes('test=true')) {
                nextLevelBtn.style.display = 'none';
            } else {
                const nextLevelNumber = parseInt(levelId) + 1;

                nextLevelBtn.onclick = () => {
                    window.location.href = `gameloader.html?level=${nextLevelNumber}`;
                };

                // Check if next level exists
                const checkScript = document.createElement('script');
                checkScript.src = `level${nextLevelNumber}.js`;

                checkScript.onload = () => {
                    nextLevelBtn.style.display = 'inline-block';
                };
                checkScript.onerror = () => {
                    nextLevelBtn.style.display = 'none';
                };
                document.body.appendChild(checkScript);
            }

            cleanupParticles();
            cancelAnimationFrame(animationFrameId);
        }

        // Add camera-related variables
        let cameraOffsetY = 0;
        const CAMERA_FOLLOW_THRESHOLD = 50; // Reduced from 100 to make camera more responsive
        const MAX_CAMERA_SPEED = 20; // Increased from 15 to make camera movement smoother

        /**
         * Main game loop that updates all game elements
         * Called every animation frame when game is running
         */
        function updateGame() {
            // Don't update if game isn't in active state
            if (!isLevelStarted || isGameOver || isLevelComplete) {
                return;
            }

            if (isPaused) {
                requestAnimationFrame(updateGame);
                return;
            }

            // Update background color as part of the game loop
            updateBackgroundColor();

            // Apply game speed to obstacle movement
            const baseSpeed = 5;  // Default speed
            const currentSpeed = isPracticeMode ? (baseSpeed * (SettingsManager.current.gameSpeed / 5)) : baseSpeed;

            // Create new obstacles when needed
            // Only creates obstacles when there's enough space from the last one
            if (currentColumn < levelMatrix[0].length &&
                (obstacles.length === 0 ||
                    gameContainer.offsetWidth - obstacles[obstacles.length - 1]?.element.offsetLeft > CONSTANTS.COLUMN_WIDTH)) {
                for (let row = 0; row < levelMatrix.length; row++) {
                    createObstacleFromMatrix(levelMatrix[row][currentColumn], row);
                }
                currentColumn++;

                // Only update progress when new obstacles are created
                updateProgress();
            }

            // Player physics calculations
            playerVelocity += gravity;
            const currentBottom = parseInt(window.getComputedStyle(player).bottom);
            let newBottom = currentBottom - playerVelocity;

            // Check ground collision with proper constants
            if (newBottom <= CONSTANTS.GROUND_HEIGHT) {
                newBottom = CONSTANTS.GROUND_HEIGHT;
                isJumping = false;
                doubleJumpAvailable = true;
                playerVelocity = 0;
            }

            // Update player position
            player.style.bottom = `${newBottom}px`;
            player.style.left = '100px'; // Keep player's horizontal position fixed

            // Rotate player during jump
            if (isJumping) {
                rotation += 5;
                player.style.transform = `rotate(${rotation}deg)`;
            } else {
                rotation = 0;
                player.style.transform = `rotate(${rotation}deg)`;
            }

            // Update obstacles with optimization
            const playerRect = player.getBoundingClientRect();
            const containerLeft = gameContainer.getBoundingClientRect().left;

            // Process each obstacle
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                let obstacleLeft = parseInt(obstacle.element.style.left);
                obstacle.element.style.left = (obstacleLeft - currentSpeed) + 'px';

                // Remove off-screen obstacles to improve performance
                if (obstacleLeft < -50) {
                    obstacle.element.remove();
                    obstacles.splice(i, 1);
                    continue;
                }

                // Only check collisions for nearby obstacles
                if (Math.abs(obstacleLeft - (playerRect.left - containerLeft)) < 100) {
                    const collision = checkCollision(player, obstacle.element);
                    if (collision) {
                        if (obstacle.type === 'finish') {
                            levelComplete();
                        } else if (obstacle.type === 'spike' && !isPracticeMode) {  // Check practice mode
                            gameOver();
                        } else if (obstacle.type === 'teleporter') {
                            const rotation = parseInt(obstacle.element.getAttribute('data-rotation') || '0');
                            
                            if (rotation === 90 || rotation === 270) {
                                // Horizontal teleport - move obstacles forward/back
                                const dx = 240; // Move obstacles forward
                                
                                // Update all obstacle positions
                                obstacles.forEach(obs => {
                                    const obsLeft = parseInt(obs.element.style.left || '0');
                                    obs.element.style.left = (obsLeft + dx) + 'px';
                                });
                                
                                // Keep player at fixed position
                                player.style.left = '100px';
                            } else {
                                // Vertical teleport
                                const dy = rotation === 180 ? -240 : 120;
                                player.style.bottom = (parseInt(player.style.bottom) + dy) + 'px';
                            }
                            
                            playerVelocity = 0;
                            createParticles('#ff00ff');
                            setTimeout(() => createParticles('#ff00ff'), 100);
                        } else if (obstacle.type === 'platform') {
                            const platformCollision = handlePlatformCollision(playerRect, obstacle.element);
                            if (platformCollision === 'death' && !isPracticeMode) {  // Check practice mode
                                gameOver();
                            }
                        }
                    }
                }
            }

            // Update particle effects
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.vy += 0.5;  // Gravity effect on particles
                particle.life -= 0.02;  // Particle fade out

                // Remove dead particles
                if (particle.life <= 0) {
                    particle.element.remove();
                    particles.splice(i, 1);
                    continue;
                }

                // Update particle position
                const currentLeft = parseFloat(particle.element.style.left);
                const currentTop = parseFloat(particle.element.style.top);

                particle.element.style.left = (currentLeft + particle.vx) + 'px';
                particle.element.style.top = (currentTop + particle.vy) + 'px';
                particle.element.style.opacity = particle.life;
            }

            // Continue game loop if game is still active
            if (!isGameOver && !isLevelComplete) {
                requestAnimationFrame(updateGame);
            }

            // Update camera position to follow player
            const containerHeight = gameContainer.offsetHeight;
            const targetCameraY = Math.max(0, newBottom - containerHeight / 2);

            // Smooth camera movement
            const cameraDistance = targetCameraY - cameraOffsetY;
            if (Math.abs(cameraDistance) > CAMERA_FOLLOW_THRESHOLD) {
                const cameraSpeed = Math.min(Math.abs(cameraDistance) * 0.1, MAX_CAMERA_SPEED);
                cameraOffsetY += Math.sign(cameraDistance) * cameraSpeed;
            }

            // Apply camera transform
            const cameraContainer = document.getElementById('cameraContainer');
            cameraContainer.style.transform = `translateY(${cameraOffsetY}px)`;
        }

        /**
         * Handles collision detection between player and obstacles
         * @param {HTMLElement} player - The player element
         * @param {HTMLElement} obstacle - The obstacle element to check collision with
         * @returns {boolean} - True if collision detected, false otherwise
         */
        function checkCollision(player, obstacle) {
            if (obstacle.classList.contains('empty-block')) return false;

            // Get raw positions without camera influence
            const playerBottom = parseInt(player.style.bottom);
            const playerLeft = parseInt(player.style.left);
            const obstacleBottom = parseInt(obstacle.style.bottom);
            const obstacleLeft = parseInt(obstacle.style.left);

            const tolerance = 5;  // Small overlap allowance for smoother collision
            const playerSize = 30; // Player width/height
            const obstacleSize = obstacle.type === 'platform' ? 45 : 30;

            // Get obstacle rotation
            let rotation = 0;
            const transform = obstacle.style.transform;
            if (transform) {
                const match = transform.match(/rotate\((\d+)deg\)/);
                if (match) {
                    rotation = parseInt(match[1]);
                }
            }

            // Adjust collision box based on rotation for spikes
            let adjustedObstacleBottom = obstacleBottom;
            let adjustedObstacleLeft = obstacleLeft;

            if (obstacle.type === 'spike') {
                switch (rotation) {
                    case 90:  // Pointing left
                        adjustedObstacleLeft += obstacleSize / 2;
                        break;
                    case 180:  // Pointing up
                        adjustedObstacleBottom += obstacleSize / 2;
                        break;
                    case 270:  // Pointing right
                        adjustedObstacleLeft -= obstacleSize / 2;
                        break;
                    default:  // Pointing down or no rotation
                        adjustedObstacleBottom -= obstacleSize / 2;
                }
            }

            // Check for overlap in both x and y directions
            return !(playerLeft + playerSize - tolerance < adjustedObstacleLeft ||
                playerLeft + tolerance > adjustedObstacleLeft + obstacleSize ||
                playerBottom + playerSize - tolerance < adjustedObstacleBottom ||
                playerBottom + tolerance > adjustedObstacleBottom + obstacleSize);
        }

        /**
         * Handles specific collision logic for platforms
         * Includes landing detection and side collision
         */
        function handlePlatformCollision(playerRect, platform) {
            // Get raw positions without camera influence
            const playerBottom = parseInt(player.style.bottom);
            const platformBottom = parseInt(platform.style.bottom);
            const playerLeft = parseInt(player.style.left);
            const platformLeft = parseInt(platform.style.left);

            // Calculate overlap using absolute positions
            const horizontalOverlap = Math.min(playerLeft + 30, platformLeft + 45) -
                Math.max(playerLeft, platformLeft);
            const playerWidth = 30;

            if (playerVelocity > 0 && // Moving downward
                playerBottom <= platformBottom + 45 && // Platform height is 45
                playerBottom >= platformBottom &&
                horizontalOverlap > playerWidth * 0.3) {

                // Safe landing
                isOnPlatform = true;
                isJumping = false;
                doubleJumpAvailable = true;
                playerVelocity = 0;
                player.style.bottom = (platformBottom + 45) + 'px';
                return 'safe';
            } else {
                // Side collision check - only if player is significantly inside the platform
                const playerCenterX = playerLeft + (playerWidth / 2);
                const platformCenterX = platformLeft + 22.5; // Half of platform width (45/2)
                const verticalOverlap = Math.min(playerBottom + 30, platformBottom + 45) -
                    Math.max(playerBottom, platformBottom);
                
                // Check if we're colliding from the side and not just grazing the top
                if (horizontalOverlap > playerWidth * 0.4 && // Significant horizontal overlap
                    verticalOverlap > 10 && // Significant vertical overlap
                    playerBottom < platformBottom + 40 && // Not near the top
                    Math.abs(playerCenterX - platformCenterX) < 20) { // Close to platform center
                    return 'death';
                }
            }
            return 'none';
        }

        /**
         * Handles game over state and UI
         * Called when player hits spikes or collides with obstacles
         */
        async function gameOver() {
            if (!isPracticeMode) {  // Only trigger game over if NOT in practice mode
                isGameOver = true;
                deathCount++;  // Track deaths

                // Stop all music immediately
                await Promise.all([
                    AudioManager.pause(AudioManager.backgroundMusic),
                    AudioManager.pause(AudioManager.practiceMusic)
                ]);

                if (!AudioManager.isMuted) {
                    AudioManager.deathSound.currentTime = 0;
                    AudioManager.deathSound.play();
                }

                // Create particles at player position
                const playerRect = player.getBoundingClientRect();
                const cameraRect = document.getElementById('cameraContainer').getBoundingClientRect();
                const relativeX = playerRect.left - cameraRect.left;
                const relativeY = cameraRect.bottom - playerRect.bottom;

                // Get color of the obstacle that caused death
                let particleColor = '#ff0000'; // Default red
                const nearbyObstacles = obstacles.filter(o =>
                    checkCollision(player, o.element) &&
                    (o.element.style.backgroundColor || o.element.style.borderBottomColor)
                );

                if (nearbyObstacles.length > 0) {
                    const obstacle = nearbyObstacles[0].element;
                    particleColor = obstacle.style.backgroundColor || obstacle.style.borderBottomColor;
                }

                createParticles(particleColor);

                // Handle auto restart
                if (autoRestartEnabled) {
                    setTimeout(() => {
                        restartGame();
                    }, 1000);
                    return;
                }

                // Show game over screen
                if (gameOverElement) {
                    gameOverElement.style.display = 'block';
                }

                // Fade out music
                if (!AudioManager.isMuted) {
                    AudioManager.fadeOut(isPracticeMode ? AudioManager.practiceMusic : AudioManager.backgroundMusic);
                }

                cancelAnimationFrame(animationFrameId);
            } else {
                // In practice mode, just reset position but keep playing
                player.style.bottom = '50px';
                playerVelocity = 0;
                rotation = 0;
                createParticles('#ff00ff'); // Different color particles for practice mode respawn
            }
        }

        /**
         * Restarts the game, resetting all necessary variables and states
         * Called after game over or when manually restarting
         */
        async function restartGame() {
            // Cancel any pending animation frames
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Reset pause state
            isPaused = false;
            pauseMenu.style.display = 'none';

            // Reset game state
            isGameOver = false;
            isLevelComplete = false;
            currentColumn = 0;
            gameSpeed = 5;
            playerVelocity = 0;
            rotation = 0;
            isOnPlatform = false;

            // Reset UI elements
            if (levelCompleteElement) {  // Add null check
                levelCompleteElement.style.display = 'none';
            }
            if (gameOverElement) {  // Add null check
                gameOverElement.style.display = 'none';
            }
            player.style.bottom = '50px';
            player.style.transform = 'rotate(0deg)';

            // Reset camera position
            cameraOffsetY = 0;
            document.getElementById('cameraContainer').style.transform = 'translateY(0)';

            // Clear obstacles and particles
            obstacles.forEach(obstacle => {
                if (obstacle.element && obstacle.element.parentNode) {
                    obstacle.element.remove();
                }
            });
            obstacles = [];

            cleanupParticles();

            // Reset jump state
            doubleJumpAvailable = true;
            passedBlocks = 0;

            // Reset progress bar
            progressFill.style.width = '0%';
            progressText.textContent = '0%';

            // Stop all music first
            await Promise.all([
                AudioManager.pause(AudioManager.backgroundMusic),
                AudioManager.pause(AudioManager.practiceMusic)
            ]);

            // Start the correct music if not muted
            if (!AudioManager.isMuted && !isPaused) {
                try {
                    const musicToPlay = isPracticeMode ? AudioManager.practiceMusic : AudioManager.backgroundMusic;
                    const musicToPause = isPracticeMode ? AudioManager.backgroundMusic : AudioManager.practiceMusic;
                    await AudioManager.switchTracks(musicToPlay, musicToPause);
                } catch (error) {
                    console.error("Audio reset failed:", error);
                }
            }

            // Restart music
            await AudioManager.restart();

            // Reset player position
            player.style.bottom = `${CONSTANTS.GROUND_HEIGHT}px`;
            playerVelocity = 0;
            rotation = 0;
            player.style.transform = 'rotate(0deg)';

            // Start game loop
            updateGame();
        }

        // ===== Event listeners for player input =====
        document.addEventListener('touchstart', jump);
        document.addEventListener('keydown', handleSpaceJump);
        document.addEventListener('mousedown', handleMouseJump);
        restartBtn.addEventListener('click', restartGame);

        /**
         * Handles player jumping mechanics
         * Includes double jump and jump buffering
         */
        function jump(e) {
            const currentTime = Date.now();

            // Check if jump is allowed (not game over and either on ground or can double jump)
            if (!isGameOver && (
                (!isJumping && !isOnPlatform) ||
                (doubleJumpAvailable && currentTime - lastJumpPressTime > jumpBufferTime)
            )) {
                if (isJumping) {
                    doubleJumpAvailable = false;
                }
                isJumping = true;
                isOnPlatform = false;
                jumpCount++;  // Track jumps
                playerVelocity = jumpForce;

                lastJumpPressTime = currentTime;

                // Play jump sound if available and not muted
                if (!AudioManager.isMuted && AudioManager.jumpSound?.readyState === 4) {
                    AudioManager.jumpSound.currentTime = 0;
                    AudioManager.jumpSound.play().catch(error => console.log("Jump sound failed:", error));
                }
            }
        }

        /**
         * Handles spacebar input for jumping
         * Prevents page scrolling on space press
         */
        function handleSpaceJump(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                jump();
            }
        }

        /**
         * Handles mouse input for jumping
         */
        function handleMouseJump(e) {
            if (e.button === 0) { // Left click only
                jump();
            }
        }

        /**
         * Updates the progress bar and level completion percentage
         * Called from updateGame when new obstacles are created
         * Throttled to avoid performance issues
         */
         function updateProgress() {
            if (!levelMatrix || levelMatrix.length === 0) return;

            const currentTime = Date.now();
            if (currentTime - lastProgressUpdate < progressUpdateInterval) return;

            // Calculate progress based on current column position
            const totalColumns = levelMatrix[0].length;
            const delayColumns = 3; // Creates a 2-second delay for smoother progress
            const adjustedColumn = Math.max(0, currentColumn - delayColumns);

            // Calculate progress with finer granularity
            const progress = (adjustedColumn / totalColumns) * 100;
            const clampedProgress = Math.min(Math.round(progress), 99); // Cap at 99% until complete

            // Only show 100% when level is actually complete
            const finalProgress = isLevelComplete ? 100 :
                progress >= 98 ? 99 : // Force 99% when near the end
                    clampedProgress;

            // Update UI elements
            const progressText = document.getElementById('progressText');
            const progressFill = document.getElementById('progressFill');

            progressText.textContent = `${finalProgress}%`;
            progressFill.style.width = `${finalProgress}%`;

            // Update progress bar colors based on completion
            if (finalProgress > 75) {
                progressFill.style.background = 'linear-gradient(90deg, #00ff00, #4287f5)';
            } else if (finalProgress > 50) {
                progressFill.style.background = 'linear-gradient(90deg, #ffff00, #00ff00)';
            } else if (finalProgress > 25) {
                progressFill.style.background = 'linear-gradient(90deg, #ffa500, #ffff00)';
            }

            // Update player indicator position on height bar
            const heightIndicator = document.getElementById('heightIndicator');
            if (heightIndicator) {
                const indicatorHeight = heightIndicator.offsetHeight;
                const playerIndicator = document.getElementById('playerIndicator');
                const position = (finalProgress / 100) * indicatorHeight;
                playerIndicator.style.top = `${position}px`;
            }

            lastProgressUpdate = currentTime;
        }

        /**
         * Calculates the total number of blocks in the level
         * Used for progress tracking and level completion
         */
        function calculateTotalBlocks() {
            // Search for finish line in level matrix
            finishLinePosition = 0;
            for (let col = 0; col < levelMatrix[0].length; col++) {
                for (let row = 0; row < levelMatrix.length; row++) {
                    if (levelMatrix[row][col] === 4) {  // 4 represents finish line
                        finishLinePosition = col;
                        break;
                    }
                }
                if (finishLinePosition > 0) break;
            }

            // Calculate total blocks up to finish line
            totalBlocks = finishLinePosition * levelMatrix.length;
            if (totalBlocks === 0) {
                console.error('No finish line found in level matrix!');
                totalBlocks = levelMatrix[0].length * levelMatrix.length;  // Fallback calculation
            }
        }

        /**
         * Gradually reduces background music volume until silent
         * Used during level completion and game over
         */
        async function fadeOutMusic() {
            const currentMusic = isPracticeMode ? AudioManager.practiceMusic : AudioManager.backgroundMusic;
            while (currentMusic.volume > 0.02) {
                currentMusic.volume -= 0.02;  // Reduce volume by 2%
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            await AudioManager.pause(currentMusic);
            currentMusic.volume = SettingsManager.current.volume / 100;  // Reset to user's volume setting
        }

        /**
         * Initializes level settings and UI controls
         * Sets up event listeners for all game settings
         */
        async function initializeLevel() {
            // Get references to all UI elements
            const settingsMenu = document.getElementById('settingsMenu');
            const volumeSlider = document.getElementById('volumeSlider');
            const volumeValue = document.getElementById('volumeValue');
            const controlMethodSelect = document.getElementById('controlMethod');
            const autoRestartCheckbox = document.getElementById('autoRestart');
            const practiceModeCheckbox = document.getElementById('practiceMode');
            const startLevelBtn = document.getElementById('startLevelBtn');
            const loadingAnimation = document.getElementById('loadingAnimation');

            // Load saved settings first
            SettingsManager.load();

            // Apply loaded settings to UI elements
            if (volumeSlider) {
                volumeSlider.value = SettingsManager.current.volume;
                volumeValue.textContent = SettingsManager.current.volume + '%';
            }

            if (controlMethodSelect) {
                controlMethodSelect.value = SettingsManager.current.controlMethod;
            }

            if (practiceModeCheckbox) {
                practiceModeCheckbox.checked = SettingsManager.current.practiceMode;
                isPracticeMode = SettingsManager.current.practiceMode;
            }

            if (autoRestartCheckbox) {
                autoRestartCheckbox.checked = SettingsManager.current.autoRestartEnabled;
                autoRestartEnabled = SettingsManager.current.autoRestartEnabled;

                // Add change event listener for auto restart
                autoRestartCheckbox.addEventListener('change', function () {
                    autoRestartEnabled = this.checked;
                    SettingsManager.current.autoRestartEnabled = autoRestartEnabled;
                    SettingsManager.save();
                });
            }

            // Visual effects setup
            const visualEffectsCheckbox = document.getElementById('visualEffects');
            if (visualEffectsCheckbox) {
                visualEffectsCheckbox.checked = SettingsManager.current.visualEffects;
                visualEffectsCheckbox.addEventListener('change', function () {
                    SettingsManager.current.visualEffects = this.checked;
                    SettingsManager.save();
                });
            }

            // Set up volume control with real-time updates
            if (volumeSlider) {
                volumeSlider.addEventListener('input', function () {
                    const volume = this.value;
                    volumeValue.textContent = volume + '%';

                    // Update settings
                    SettingsManager.current.volume = volume;
                    SettingsManager.save();

                    // Apply volume to all audio elements
                    [AudioManager.backgroundMusic, AudioManager.practiceMusic, AudioManager.jumpSound, AudioManager.deathSound, AudioManager.completionSound].forEach(audio => {
                        if (audio) {
                            audio.volume = SettingsManager.current.volume / 100;
                        }
                    });
                });
            }

            // Practice mode setup
            if (practiceModeCheckbox) {
                practiceModeCheckbox.addEventListener('change', async function () {
                    isPracticeMode = this.checked;
                    SettingsManager.current.practiceMode = isPracticeMode;
                    SettingsManager.save();

                    // Enable/disable game speed control
                    const gameSpeedSelect = document.getElementById('gameSpeed');
                    if (gameSpeedSelect) {
                        gameSpeedSelect.disabled = !isPracticeMode;
                        if (!isPracticeMode) {
                            gameSpeed = 5;
                            gameSpeedSelect.value = "1";
                            SettingsManager.current.gameSpeed = gameSpeed;
                            SettingsManager.save();
                        } else {
                            // Initialize game speed when practice mode is enabled
                            gameSpeed = SettingsManager.current.gameSpeed || 5;
                            gameSpeedSelect.value = (gameSpeed / 5).toString();
                        }
                    }

                    // Only switch music if the level is actually running
                    if (isLevelStarted && !isPaused && !isGameOver && !isLevelComplete) {
                        try {
                            const musicToPlay = isPracticeMode ? AudioManager.practiceMusic : AudioManager.backgroundMusic;
                            const musicToPause = isPracticeMode ? AudioManager.backgroundMusic : AudioManager.practiceMusic;
                            await AudioManager.switchTracks(musicToPlay, musicToPause);
                        } catch (error) {
                            console.error("Error switching music tracks:", error);
                        }
                    } else {
                        // If level isn't running, make sure both music tracks are paused
                        await Promise.all([
                            AudioManager.pause(AudioManager.backgroundMusic),
                            AudioManager.pause(AudioManager.practiceMusic)
                        ]);
                    }
                });
            }

            // Game speed setup
            const gameSpeedSelect = document.getElementById('gameSpeed');
            if (gameSpeedSelect) {
                // Initialize game speed select state
                gameSpeedSelect.disabled = !isPracticeMode;
                if (SettingsManager.current.gameSpeed) {
                    gameSpeed = SettingsManager.current.gameSpeed;
                    gameSpeedSelect.value = gameSpeed.toString();
                }

                gameSpeedSelect.addEventListener('change', function () {
                    if (isPracticeMode) {
                        const speedMultiplier = parseFloat(this.value);
                        gameSpeed = 5 * speedMultiplier;
                        SettingsManager.current.gameSpeed = gameSpeed;
                        SettingsManager.save();
                    }
                });
            }

            // Control method setup
            if (controlMethodSelect) {
                controlMethodSelect.addEventListener('change', function () {
                    const method = this.value;
                    SettingsManager.current.controlMethod = method;
                    SettingsManager.save();
                    setupControls(method);
                    console.log("Control Method: ", method, " set")
                });
            }
        }

        /**
         * Configures control scheme based on user selection
         * @param {string} method - 'space', 'click', or 'both'
         */
        function setupControls(method) {
            // Remove all existing event listeners first
            document.removeEventListener('keydown', handleSpaceJump);
            document.removeEventListener('mousedown', handleMouseJump);
            document.removeEventListener('keydown', (e) => {
                if (e.code === 'Space') jump();
            });

            // Apply new control scheme
            if (method === 'space') {
                document.addEventListener('keydown', handleSpaceJump);
            } else if (method === 'click') {
                document.addEventListener('mousedown', handleMouseJump);
            } else if (method === 'both') {
                document.addEventListener('keydown', handleSpaceJump);
                document.addEventListener('mousedown', handleMouseJump);
            }
        }

        /**
         * Preloads all game assets before starting
         * Returns a Promise that resolves when all assets are loaded
         */
        async function preloadAssets() {
            await Promise.all([
                loadAudio(),
                loadImages(),
                loadLevelData()
            ]);
        }

        /**
         * Toggles game pause state and updates UI accordingly
         * Handles music pause/resume and button icons
         */
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyP') {
                toggleGameState('pause');
            }
        });

        // Resume game from pause menu
        document.getElementById('resumeBtn').addEventListener('click', () => toggleGameState('pause'));

        // Restart game from pause menu
        document.getElementById('restartFromPauseBtn').addEventListener('click', () => {
            pauseMenu.style.display = 'none';
            isPaused = false;
            location.reload();
        });

        // Toggle pause with pause button
        document.getElementById('pauseButton').addEventListener('click', () => toggleGameState('pause'));

        // Escape key handler
        document.addEventListener('keydown', (e) => {
            if (e.key === "Escape") {
                toggleGameState('pause');
            }
        });

        // Smooth background transition logic using the color codes
        const colorSteps = [
            COLOR_MAP['0'],
            COLOR_MAP['-1'],
            COLOR_MAP['-2'],
            COLOR_MAP['-3'],
            COLOR_MAP['-4'],
            COLOR_MAP['-5'],
            COLOR_MAP['-6'],
            COLOR_MAP['-7'],
            COLOR_MAP['-8'],
            COLOR_MAP['-9']

        ];
        let colorIndex = 0;
        let transitionFactor = 0;
        const totalTransitionTime = 10; // Total time for all transitions

        // Calculate transition speed and duration
        const numberOfTransitions = colorSteps.length - 1;
        const transitionDuration = totalTransitionTime / numberOfTransitions;
        const transitionSpeed = 1 / (transitionDuration * 60); // Assuming 60 frames per second

        // ===== Color =====
        const COLOR_TRANSITION = {
            DURATION: 2,    // Duration of each color transition in seconds
            SPEED: 0.0052    // Speed of transition (smaller = slower)
        };

        // Update the updateBackgroundColor function
        function updateBackgroundColor() {
            // Basic validation
            if (!levelMatrix || !levelMatrix.length || !levelColorRow) return;
            
            try {
                // Account for initial empty space using CONSTANTS
                const delayColumns = Math.floor(CONSTANTS.INITIAL_SPACE / CONSTANTS.COLUMN_WIDTH);
                const adjustedColumn = Math.max(0, currentColumn - delayColumns);
                
                // Get current and next codes from the stored color row
                const currentRawCode = levelColorRow[adjustedColumn];
                const nextRawCode = levelColorRow[Math.min(adjustedColumn + 1, levelColorRow.length - 1)];

                // Don't force negative numbers, allow 0 for black
                const currentCode = `${extractColorCode(currentRawCode) || 0}`;
                const nextCode = `${extractColorCode(nextRawCode) || 0}`;

                // Get colors from color map
                const currentColor = COLOR_MAP[currentCode] || '#000000';  // Default to black
                const nextColor = COLOR_MAP[nextCode] || '#000000';
                
                if (!currentColor || !nextColor) {
                    console.error('Invalid color codes:', currentCode, nextCode);
                    return;
                }

                // Create darker versions
                const currentDarkerColor = makeColorDarker(currentColor);
                const nextDarkerColor = makeColorDarker(nextColor);
                
                const gameContainer = document.getElementById('gameContainer');
                if (!gameContainer) return;

                // If colors are the same, no need to interpolate
                if (currentCode === nextCode) {
                    gameContainer.style.backgroundColor = currentDarkerColor;
                    gameContainer.style.transition = 'none';
                    return;
                }
                
                // Calculate transition
                const rowSpacing = 45;  // Match platform block width
                const factor = (player.x % rowSpacing) / rowSpacing;
                const newColor = interpolateColor(currentDarkerColor, nextDarkerColor, factor);
                
                // Apply the new color if valid
                if (newColor && newColor.length === 7) {
                    gameContainer.style.backgroundColor = newColor;
                    gameContainer.style.transition = 'none';
                }
            } catch (error) {
                console.error('[Color Transition] Error:', error);
            }
        }

        // Update the interpolateColor function for smoother transitions
        function interpolateColor(color1, color2, factor) {
            if (!color1 || !color2 || typeof color1 !== 'string' || typeof color2 !== 'string') {
                return COLOR_MAP['0'];
            }
            // Ensure factor is between 0 and 1
            factor = Math.max(0, Math.min(1, factor));

            // Parse colors
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);

            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);

            // Interpolate using cubic easing for smoother transitions
            const ease = factor * factor * (3 - 2 * factor);

            // Calculate new color values
            const r = Math.round(r1 + (r2 - r1) * ease);
            const g = Math.round(g1 + (g2 - g1) * ease);
            const b = Math.round(b1 + (b2 - b1) * ease);

            // Convert back to hex
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        // Make colors darker for background
        function makeColorDarker(color) {
            if (!color || typeof color !== 'string' || !color.startsWith('#')) {
                return COLOR_MAP['0'];  // Return default color if input is invalid
            }

            try {
                // Convert hex to RGB
                const r = parseInt(color.slice(1,3), 16) || 0;
                const g = parseInt(color.slice(3,5), 16) || 0;
                const b = parseInt(color.slice(5,7), 16) || 0;
                
                // Make each component 40% darker
                const darkerR = Math.max(0, Math.floor(r * 0.6));
                const darkerG = Math.max(0, Math.floor(g * 0.6));
                const darkerB = Math.max(0, Math.floor(b * 0.6));
                
                // Convert back to hex
                return `#${darkerR.toString(16).padStart(2,'0')}${darkerG.toString(16).padStart(2,'0')}${darkerB.toString(16).padStart(2,'0')}`;
            } catch (error) {
                console.error('Error in makeColorDarker:', error);
                return COLOR_MAP['0'];  // Return default color on error
            }
        }

        function extractColorCode(code) {
            if (typeof code === 'string') {
                const props = code.split('/');
                const colorProp = props.find(p => p.startsWith('-'));
                return colorProp ? parseInt(colorProp) : -1;
            }
            return code;
        }

        /**
         * Enhanced level data validation
         * @throws {Error} If validation fails
         */
        function validateLevelData(matrix) {
            if (!matrix || !Array.isArray(matrix)) {
                throw new Error('Invalid level data: matrix must be an array');
            }

            if (matrix.length < 2) {
                throw new Error('Invalid level data: matrix must have at least 2 rows');
            }

            const width = matrix[0].length;
            if (width === 0) {
                throw new Error('Invalid level data: matrix rows cannot be empty');
            }

            // Validate first row (color codes)
            const colorRow = matrix[0];
            colorRow.forEach((code, index) => {
                if (typeof code === 'string') {
                    const props = code.split('/');
                    // First property is always the type
                    blockType = parseInt(props[0]);

                    // Process other properties
                    for (let i = 1; i < props.length; i++) {
                        const prop = props[i];
                        if (prop.startsWith('-')) {
                            // Color property (negative number)
                            blockColor = COLOR_MAP[parseInt(prop)];
                        } else if (prop.startsWith('@')) {
                            // Rotation property
                            blockRotation = parseInt(prop.substring(1));
                        }
                    }
                } else if (code < 0 && !COLOR_MAP[code]) {
                    throw new Error(`Invalid color code ${code} at position ${index} in color row`);
                }
            });

            // Validate level rows
            for (let i = 1; i < matrix.length; i++) {
                const row = matrix[i];
                if (row.length !== width) {
                    throw new Error(`Invalid level data: row ${i} has different width than first row`);
                }

                row.forEach((block, j) => {
                    if (typeof block === 'string') {
                        const props = block.split('/');
                        // First property is always the type
                        block = parseInt(props[0]);

                        // Process other properties
                        for (let i = 1; i < props.length; i++) {
                            const prop = props[i];
                            if (prop.startsWith('-')) {
                                // Color property (negative number)
                                const colorCode = parseInt(prop);
                                if (!COLOR_MAP[colorCode]) {
                                    throw new Error(`Invalid color code ${prop} at position [${i},${j}]`);
                                }
                            } else if (prop.startsWith('@')) {
                                // Rotation property
                                const rotation = parseInt(prop.substring(1));
                                if (![0, 90, 180, 270].includes(rotation)) {
                                    throw new Error(`Invalid rotation ${prop} at position [${i},${j}]`);
                                }
                            } else {
                                throw new Error(`Invalid block property ${prop} at position [${i},${j}]`);
                            }
                        }
                    } else if (typeof block !== 'number' || block < 0 || block > 4) {
                        throw new Error(`Invalid block type ${block} at position [${i},${j}]`);
                    }
                });
            }

            return true;
        }

        /**
         * Enhanced touch controls setup
         */
        function initializeTouchControls() {
            const touchThreshold = 20; // pixels
            let touchStartY = 0;
            let isSwiping = false;

            document.addEventListener('touchstart', function (e) {
                e.preventDefault();
                touchStartY = e.touches[0].clientY;
                isSwiping = false;
            }, { passive: false });

            document.addEventListener('touchmove', function (e) {
                if (Math.abs(e.touches[0].clientY - touchStartY) > touchThreshold) {
                    isSwiping = true;
                }
            }, { passive: false });

            document.addEventListener('touchend', function (e) {
                e.preventDefault();
                if (!isPaused && !isGameOver && !isLevelComplete && !isSwiping) {
                    jump();
                }
            }, { passive: false });
        }

        // Add cleanup function for when leaving the page
        window.addEventListener('beforeunload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });

        console.log('All functions defined and listeners added');

        // Check if button exists
        const startLevelBtn = document.getElementById('startLevelBtn');
        if (startLevelBtn) {
            startLevelBtn.addEventListener('click', async function () {
                const loadingAnimation = document.getElementById('loadingAnimation');
                const settingsMenu = document.getElementById('settingsMenu');

                try {
                    // Load level data first
                    await LevelLoader.initializeLevelData();

                    // Rest of your start button code...
                    loadingAnimation.style.display = 'block';
                    this.style.display = 'none';

                    // Reset game state
                    isGameOver = false;
                    isLevelComplete = false;
                    isPaused = false;
                    currentColumn = 0;
                    playerVelocity = 0;
                    rotation = 0;

                    // Clear any existing animation frame
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }

                    // Hide settings menu and start game
                    settingsMenu.style.display = 'none';

                    // Reset game state before starting
                    gameSpeed = 5;
                    currentColumn = 0;
                    playerVelocity = 0;
                    rotation = 0;
                    isOnPlatform = false;
                    doubleJumpAvailable = true;

                    // Setup audio and wait for it to be ready
                    await AudioManager.setup(levelMusic);

                    // Start the appropriate music
                    if (!AudioManager.isMuted) {
                        try {
                            const musicToPlay = isPracticeMode ? AudioManager.practiceMusic : AudioManager.backgroundMusic;
                            const musicToPause = isPracticeMode ? AudioManager.backgroundMusic : AudioManager.practiceMusic;
                            await AudioManager.switchTracks(musicToPlay, musicToPause);
                        } catch (error) {
                            console.error("Error playing music:", error);
                        }
                    }

                    isLevelStarted = true;

                    // Reset animation frame if it exists
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }

                    // Start the game loop
                    initializeLevel();
                    isLevelStarted = true;
                    // Start the level timer
                    levelTime = 0;
                    levelTimer = setInterval(() => {
                        if (!isPaused && !isGameOver && !isLevelComplete) {
                            levelTime++;
                            // Update timer display
                            const timerDisplay = document.getElementById('timer');
                            if (timerDisplay) {
                                const minutes = Math.floor(levelTime / 60);
                                const seconds = levelTime % 60;
                                timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                            }
                        }
                    }, 1000);
                    requestAnimationFrame(updateGame);

                } catch (error) {
                    console.error("Failed to start level:", error);
                    loadingAnimation.style.display = 'none';
                    this.style.display = 'block';
                    alert('Failed to start level. Please try again.');
                }
            });
        } else {
            console.error('Start button not found in DOM!');
        }

        /**
         * Cleans up all particle effects
         * Called during game restart and level completion
         */
        function cleanupParticles() {
            // Remove all particle elements from DOM
            particles.forEach(particle => {
                if (particle.element && particle.element.parentNode) {
                    particle.element.remove();
                }
            });
            // Clear particles array
            particles = [];
        }

        //===== Error Handling =====
        function showError(message, container) {
            const errorElement = document.createElement('div');
            errorElement.className = 'error-message';
            errorElement.innerHTML = `
                <p>${message}</p>
                <button onclick="this.parentElement.remove()">OK</button>
            `;
            container.appendChild(errorElement);
        }

        function showLoadingError(message, isBuiltIn = false) {
            const container = document.querySelector(
                isBuiltIn ? '.built-in-levels #current-level' : '.online-levels #current-level'
            );
            if (container) {
                container.innerHTML = `<p>${message}</p>`;
            }
        }

    </script>
</body>

</html>
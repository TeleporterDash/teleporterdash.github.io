<!DOCTYPE html>
<html>
<head>
    <title>Teleporter Dash Level Editor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');

        body {
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            background: #1a1a1a;
            font-family: 'Orbitron', sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #editorContainer {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            width: 100%;
        }

        #gridContainer {
            flex: 1;
            height: 400px;
            background: #000;
            overflow: auto;
            border: 2px solid #333;
            position: relative;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-width, 100), 40px);
            grid-template-rows: repeat(var(--grid-height, 5), 60px);
            gap: 2px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.05);
        }

        .cell {
            width: 40px;
            height: 60px;
            border: 1px solid #333;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .cell:hover {
            border-color: #0F9D58;
        }

        .cell.empty {
            background: transparent;
        }

        .cell.platform {
            background: #4287f5;
        }

        .cell.spike {
            background: #ff0000;
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        }

        .cell.teleporter {
            background: linear-gradient(to right, #ff00ff, #8c00ff);
            animation: glow 1s infinite alternate;
        }

        .cell.finish {
            background: #00ff00;
        }

        #editorControls {
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group input,
        .control-group select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #333;
            background: #222;
            color: white;
        }

        .tool-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .tool {
            padding: 10px;
            background: #4285F4;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .tool.active {
            background: #0F9D58;
        }

        .action-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .action-group button {
            padding: 10px 20px;
            background: #0F9D58;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .action-group button:hover {
            background: #0B8043;
        }

        #previewMusic {
            padding: 5px 10px;
            background: #4285F4;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            margin-top: 5px;
        }

        @keyframes glow {
            from { box-shadow: 0 0 5px #ff00ff; }
            to { box-shadow: 0 0 20px #ff00ff; }
        }

        #exportArea {
            width: 100%;
            height: 100px;
            margin-top: 20px;
            background: #222;
            color: white;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            font-family: monospace;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            color: #0F9D58;
            text-shadow: 0 0 10px #0F9D58;
        }
    </style>
</head>
<body>
    <h1 class="header">Teleporter Dash Level Editor</h1>
    <div id="editorContainer">
        <div id="gridContainer">
            <div id="grid"></div>
        </div>
        <div id="editorControls">
            <div class="control-group">
                <label for="levelName">Level Name:</label>
                <input type="text" id="levelName" placeholder="Untitled Level">
            </div>
            
            <div class="control-group">
                <label for="musicSelect">Background Music:</label>
                <select id="musicSelect">
                    <option value="StereoMadness.mp3">Stereo Madness</option>
                    <option value="BackOnTrack.mp3">Back on Track</option>
                    <option value="Polargeist.mp3">Polargeist</option>
                    <option value="DryOut.mp3">Dry Out</option>
                    <option value="BaseAfterBase.mp3">Base After Base</option>
                    <option value="custom">Custom Music...</option>
                </select>
                <input type="file" id="customMusicInput" accept="audio/*" style="display: none;">
    <button id="previewMusic">Preview Music</button>
            </div>

            <div class="control-group">
                <label>Grid Size:</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <div>
                        <label for="gridWidth">Width:</label>
                        <input type="number" id="gridWidth" value="100" min="10" max="500" style="width: 70px;">
                    </div>
                    <div>
                        <label for="gridHeight">Height:</label>
                        <input type="number" id="gridHeight" value="5" min="3" max="10" style="width: 70px;">
                    </div>
                    <button id="updateGridSize" style="padding: 5px 10px; background: #4285F4; border: none; border-radius: 5px; color: white; cursor: pointer;">
                        Update Grid
                    </button>
                </div>
            </div>

            <div class="control-group">
                <label>Tools:</label>
                <div class="tool-group">
                    <button class="tool active" data-type="0">Empty</button>
                    <button class="tool" data-type="1">Platform</button>
                    <button class="tool" data-type="2">Spike</button>
                    <button class="tool" data-type="3">Teleporter</button>
                    <button class="tool" data-type="4">Finish</button>
                </div>
            </div>

            <div class="action-group">
                <button id="exportBtn">Export Level</button>
                <button id="testBtn">Test Level</button>
                <button id="clearBtn">Clear Grid</button>
            </div>

            <textarea id="exportArea" readonly placeholder="Exported level data will appear here..."></textarea>
        </div>
    </div>
    <audio id="musicPreview"></audio>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script>
        const grid = document.getElementById('grid');
        const tools = document.querySelectorAll('.tool');
        const exportBtn = document.getElementById('exportBtn');
        const testBtn = document.getElementById('testBtn');
        const clearBtn = document.getElementById('clearBtn');
        const exportArea = document.getElementById('exportArea');
        const musicSelect = document.getElementById('musicSelect');
        const musicPreview = document.getElementById('musicPreview');
        const previewMusicBtn = document.getElementById('previewMusic');
        const levelNameInput = document.getElementById('levelName');

        let currentTool = '0';
        let isMouseDown = false;

        // Add these variables at the top with other declarations
        let customMusicFile = null;
        const customMusicInput = document.getElementById('customMusicInput');

        // Update music selection handler
        musicSelect.addEventListener('change', function() {
            if (this.value === 'custom') {
                customMusicInput.click();
            }
        });

        // Add these variables at the top with other declarations
        const gridWidthInput = document.getElementById('gridWidth');
        const gridHeightInput = document.getElementById('gridHeight');
        const updateGridSizeBtn = document.getElementById('updateGridSize');
        let GRID_WIDTH = 100;
        let GRID_HEIGHT = 5;

        // Initialize levelMatrix with correct dimensions
        let levelMatrix = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0));

        // Add this function to update the grid size
        function updateGridSize() {
            const newWidth = parseInt(gridWidthInput.value);
            const newHeight = parseInt(gridHeightInput.value);
            
            // Validate input
            if (newWidth < 10 || newWidth > 500 || newHeight < 3 || newHeight > 10) {
                alert('Invalid grid size! Width must be between 10-500 and height between 3-10.');
                return;
            }
            
            // Update grid CSS variables
            grid.style.setProperty('--grid-width', newWidth);
            grid.style.setProperty('--grid-height', newHeight);
            
            // Create new matrix with old data preserved
            const newMatrix = Array(newHeight).fill().map((_, row) => {
                return Array(newWidth).fill().map((_, col) => {
                    if (row < levelMatrix.length && col < levelMatrix[0].length) {
                        return levelMatrix[row][col];
                    }
                    return 0;
                });
            });
            
            GRID_WIDTH = newWidth;
            GRID_HEIGHT = newHeight;
            levelMatrix = newMatrix;
            
            // Recreate the grid
            createGrid();
        }

        // Add event listener for the update button
        updateGridSizeBtn.addEventListener('click', updateGridSize);

        // Update the createGrid function to create cells from top to bottom
        function createGrid() {
            grid.innerHTML = '';
            grid.style.setProperty('--grid-width', GRID_WIDTH);
            grid.style.setProperty('--grid-height', GRID_HEIGHT);
            
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell empty';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    cell.addEventListener('mousedown', (e) => {
                        isMouseDown = true;
                        handleCellClick(e);
                    });
                    cell.addEventListener('mouseover', (e) => {
                        if (isMouseDown) handleCellClick(e);
                    });
                    
                    grid.appendChild(cell);
                }
            }
            updateGridVisuals();
        }

        // Stop drawing when mouse is released
        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // Handle tool selection
        tools.forEach(tool => {
            tool.addEventListener('click', () => {
                tools.forEach(t => t.classList.remove('active'));
                tool.classList.add('active');
                currentTool = tool.dataset.type;
            });
        });

        // Handle cell clicks
        function handleCellClick(e) {
            const cell = e.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            // Update matrix
            levelMatrix[row][col] = parseInt(currentTool);
            updateGridVisuals();
        }

        // Update grid visuals
        function updateGridVisuals() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const value = levelMatrix[row][col];
                
                cell.className = 'cell';
                switch(value) {
                    case 0: cell.classList.add('empty'); break;
                    case 1: cell.classList.add('platform'); break;
                    case 2: cell.classList.add('spike'); break;
                    case 3: cell.classList.add('teleporter'); break;
                    case 4: cell.classList.add('finish'); break;
                }
            });
        }

        // Preview music functionality
        previewMusicBtn.addEventListener('click', () => {
            if (musicPreview.paused) {
                if (musicSelect.value === 'custom' && customMusicFile) {
                    musicPreview.src = URL.createObjectURL(customMusicFile);
                } else {
                    musicPreview.src = 'LevelSoundtracks/' + musicSelect.value;
                }
                musicPreview.play();
                previewMusicBtn.textContent = 'Stop Preview';
            } else {
                musicPreview.pause();
                musicPreview.currentTime = 0;
                previewMusicBtn.textContent = 'Preview Music';
            }
        });


        // Export level
        // Update export functionality
        exportBtn.addEventListener('click', () => {
            const levelName = levelNameInput.value || 'Untitled Level';
            let musicFile = musicSelect.value;
            const zip = new JSZip();
                
                    // Add the level HTML content
            if (musicSelect.value === 'custom' && customMusicFile) {
                musicFile = 'custom_' + customMusicFile.name;
            }

            // Create README content based on music type
            const readmeContent = [
                `Level: ${levelName}`,
                `Music File Required: ${musicFile}`,
                ``,
                `Setup Instructions:`,
                `1. Extract all files from this zip`,
            ];

            // Add specific instructions based on music type
            if (musicSelect.value === 'custom' && customMusicFile) {
                readmeContent.push(
                    `2. The music file is included in this zip - move it to the LevelSoundtracks folder in the root of the TeleporterDash directory`,
                    `3. Move the HTML file in the root of the TeleporterDash directory`,
                    `4. Open ${levelName}.html in your browser to play the level`
                );
            } else {
                readmeContent.push(
                    `2. Copy "${levelName}.html" to the root of the TeleporterDash directory`,
                    `3. Open ${levelName}.html in your browser to play the level`
                );
            }

            // Add README to zip
            zip.file('README.txt', readmeContent.join('\n'));


            // Add the level HTML content
            const levelContent = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${levelName}</title>
    <style>
       body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            position: relative;
            width: 1000px;
            height: 400px;
            background: #000;
            overflow: hidden;
            perspective: 1000px;
        }
        #cameraContainer {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.1s ease-out;
        }
        #heightIndicator {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 5px;
            height: 200px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            z-index: 1001;
        }
        #playerIndicator {
            position: absolute;
            right: -2.5px;
            width: 10px;
            height: 10px;
            background: #00ff00;
            border-radius: 50%;
            transform: translateY(-50%);
            transition: top 0.1s ease-out;
        }
        #player {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #22c830;
            bottom: 50px;
            left: 100px;
            z-index: 1000;
            transform-origin: center;
        }
        .platform {
            position: absolute;
            background: #4287f5;
            bottom: 50px;
        }
        .spike {
            position: absolute;
            bottom: 50px;
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 30px solid #ff0000;
        }
        #ground {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 50px;
            background: #333;
        }
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 48px;
            display: none;
            text-align: center;
        }
        #restartBtn {
            padding: 10px 20px;
            font-size: 18px;
            margin-top: 20px;
            cursor: pointer;
            background: #00ff00;
            border: none;
            border-radius: 5px;
        }
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #00ff00;
            border-radius: 50%;
            pointer-events: none;
        }
        
        .teleporter {
            position: absolute;
            width: 30px;
            height: 60px;
            background: linear-gradient(to right, #ff00ff, #8c00ff);
            bottom: 50px;
            border-radius: 15px;
            animation: glow 1s infinite alternate;
        }
        
        @keyframes glow {
            from { box-shadow: 0 0 5px #ff00ff; }
            to { box-shadow: 0 0 20px #ff00ff; }
        }

        /* Add level complete styling */
        #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 48px;
            display: none;
            text-align: center;
            z-index: 100;
        }

        #progressContainer {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 200px;
            color: white;
            font-size: 18px;
            text-align: left;
            z-index: 1001;
        }

        #progressBar {
            width: 100%;
            height: 10px;
            background-color: rgba(51, 51, 51, 0.5);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #progressFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #4287f5);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        /* Add tooltip styling */
        [title] {
            position: relative;
            cursor: help;
        }

        [title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 1001;
        }

        /* Loading animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Add better touch controls and responsive design */
        @media (max-width: 768px) {
            #gameContainer {
                width: 100%;
                height: 300px;
            }
        }

        #muteButton {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 20px;
            z-index: 1001;
        }

        #pauseButton {
            position: fixed;
            top: 20px;
            right: 70px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 20px;
            z-index: 1001;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="cameraContainer">
            <div id="levelComplete">
                Level Complete!
                <br>
                <button id="nextLevelBtn" style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Next Level</button>
                <button onclick="window.location.href='teleporterdashmenu.html'" style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Back to Menu</button>
            </div>
            <div id="player"></div>
            <div id="ground"></div>
        </div>
        <div id="progressContainer">
            Completion: <span id="progressText">0%</span>
            <div id="progressBar">
                <div id="progressFill"></div>
            </div>
        </div>
        <div id="heightIndicator">
            <div id="playerIndicator"></div>
        </div>
        <button id="muteButton">🔊</button>
        <button id="pauseButton">⏸</button>
        <div id="gameOver">
            Game Over!
            <br>
            <button id="restartBtn">Try Again</button>
            <button onclick="window.location.href='teleporterdashmenu.html'" style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin-top: 10px; cursor: pointer;">Back to Menu</button>
        </div>
        <div id="settingsMenu" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 20px; border-radius: 10px; color: white; text-align: center; z-index: 1000;">
            <h2>Level Settings</h2>
            
            <!-- Volume Control with tooltip -->
            <div style="margin: 20px 0;" title="Adjust the game's overall volume">
                <label>Volume: </label>
                <input type="range" id="volumeSlider" min="0" max="100" value="90" style="width: 200px;">
                <span id="volumeValue">90%</span>
            </div>

            <!-- Practice Mode with tooltip -->
            <div style="margin: 20px 0;" title="In practice mode, you won't die and can practice the level freely">
                <label>Practice Mode: </label>
                <input type="checkbox" id="practiceMode">
            </div>

            <!-- Custom Controls with tooltip -->
            <div style="margin: 20px 0;" title="Choose your preferred control method">
                <label>Control Method: </label>
                <select id="controlMethod" style="padding: 5px; margin-left: 10px;">
                    <option value="space">Spacebar</option>
                    <option value="click">Mouse Click</option>
                    <option value="both" selected>Both</option>
                </select>
            </div>

            <!-- Auto-Restart with tooltip -->
            <div style="margin: 20px 0;" title="Automatically restart the level when you die">
                <label>Auto-Restart: </label>
                <input type="checkbox" id="autoRestart">
            </div>

            <!-- Speed Control with tooltip -->
            <div style="margin: 20px 0;" title="Adjust the game speed (Practice Mode only)">
                <label>Game Speed: </label>
                <select id="gameSpeed" style="padding: 5px; margin-left: 10px;">
                    <option value="0.5">0.5x</option>
                    <option value="1" selected>1x</option>
                    <option value="2">2x</option>
                    <option value="3">3x</option>
                </select>
            </div>

            <!-- Visual Effects with tooltip -->
            <div style="margin: 20px 0;" title="Toggle particle effects and visual enhancements">
                <label>Visual Effects: </label>
                <input type="checkbox" id="visualEffects" checked>
            </div>

            <!-- Loading animation -->
            <div id="loadingAnimation" style="display: none; margin: 20px 0;">
                <div style="width: 50px; height: 50px; border: 5px solid #f3f3f3; border-top: 5px solid #00ff00; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"></div>
                <p>Preparing Level...</p>
            </div>

            <button id="startLevelBtn" style="background: #00ff00; color: black; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">
                Start Level
            </button>
        </div>
        <div id="pauseMenu" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 20px; border-radius: 10px; color: white; text-align: center; z-index: 1000;">
            <h2>Game Paused</h2>
            <button id="resumeBtn" style="background: #00ff00; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Resume</button>
            <button id="restartFromPauseBtn" style="background: #4285F4; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Restart</button>
            <button onclick="window.location.href='teleporterdashmenu.html'" style="background: #ff4444; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin: 10px; cursor: pointer;">Exit to Menu</button>
        </div>
    </div>

    <script>
        // Define level matrix
        const levelMatrix = ${JSON.stringify(levelMatrix, null, 8)};

        // Game variables
        const player = document.getElementById('player');
        const gameContainer = document.getElementById('gameContainer');
        const gameOverElement = document.getElementById('gameOver');
        const restartBtn = document.getElementById('restartBtn');
        const levelCompleteElement = document.getElementById('levelComplete');
        const nextLevelBtn = document.getElementById('nextLevelBtn');
        const settingsMenu = document.getElementById('settingsMenu');
        const startLevelBtn = document.getElementById('startLevelBtn');

        // Move magic numbers to constants
        const CONSTANTS = {
            GRAVITY: 0.6,
            JUMP_FORCE: -15,
            BASE_GAME_SPEED: 8,
            COLUMN_WIDTH: 40,
            GROUND_HEIGHT: 50,
            // etc...
        };

        let isJumping = false;
        let gravity = CONSTANTS.GRAVITY;
        let jumpForce = CONSTANTS.JUMP_FORCE;
        let playerVelocity = 0;
        let gameSpeed = CONSTANTS.BASE_GAME_SPEED;
        let isGameOver = false;
        let rotation = 0;
        let obstacles = [];
        let animationFrameId;
        let isLevelComplete = false;
        let currentColumn = 0;
        let doubleJumpAvailable = true;
        let particles = [];
        let isOnPlatform = false;

        const progressText = document.getElementById('progressText');
        const progressFill = document.getElementById('progressFill');
        const totalColumns = levelMatrix[0].length;

        let jumpBufferTime = 100; // milliseconds
        let lastJumpPressTime = 0;

        let lastProgressUpdate = 0;
        const progressUpdateInterval = 16; // ~60fps update frequency
        let totalBlocks = 0;
        let passedBlocks = 0;

        let finishLinePosition = 0;

        let backgroundMusic;
        let jumpSound;
        let deathSound;
        let completionSound;
        let isMuted = false;

        let isPracticeMode = false;
        let isLevelStarted = false;

        let autoRestartEnabled = false;
        let isRestarting = false;

        let isPaused = false;
        const pauseMenu = document.getElementById('pauseMenu');

        // Consider using a game state object
        const gameState = {
            isJumping: false,
            isPracticeMode: false,
            isGameOver: false,
            currentColumn: 0,
            // etc...
        };

        // Create settings manager
        const SettingsManager = {
            current: {
                volume: 90,
                practiceMode: false,
                controlMethod: 'both'
            },
            save() {
                localStorage.setItem('gameSettings', JSON.stringify(this.current));
            },
            load() {
                // Load saved settings
            }
        };

        // Include all game functions
        function setupAudio() {
            try {
                backgroundMusic = new Audio('LevelSoundtracks/${musicFile}');
                backgroundMusic.loop = true;
                backgroundMusic.volume = 0.9;
                
                jumpSound = new Audio('BasicSoundEffects/jumptd.mp3');
                jumpSound.volume = 0.2;
                
                deathSound = new Audio('BasicSoundEffects/deathtd.mp3');
                deathSound.volume = 0.7;
                
                completionSound = new Audio('BasicSoundEffects/lvlcompletetd.mp3');
                completionSound.volume = 0.7;
            } catch (error) {
                console.error("Audio setup failed:", error);
            }
        }
        function toggleMute() {
            isMuted = !isMuted;
            backgroundMusic.muted = isMuted;
            jumpSound.muted = isMuted;
            deathSound.muted = isMuted;
            completionSound.muted = isMuted;
        }

        // Add this after other event listeners
        document.getElementById('muteButton').addEventListener('click', function() {
            toggleMute();
            this.textContent = isMuted ? '🔈' : '🔊';
        });

        function createParticles() {
            for (let i = 0; i < 5; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                const rect = player.getBoundingClientRect();
                particle.style.left = (rect.left + rect.width/2) + 'px';
                particle.style.bottom = (parseInt(player.style.bottom) || 50) + 'px';
                gameContainer.appendChild(particle);
                
                const angle = Math.random() * Math.PI * 2;
                const velocity = 5 + Math.random() * 5;
                particles.push({
                    element: particle,
                    vx: Math.cos(angle) * velocity,
                    vy: Math.sin(angle) * velocity,
                    life: 1
                });
            }
        }

        function createObstacleFromMatrix(type, row) {
            if (type === 0) {
                const emptyBlock = document.createElement('div');
                emptyBlock.className = 'empty-block';
                emptyBlock.type = 'empty';
                emptyBlock.style.position = 'absolute';
                emptyBlock.style.width = '30px';
                emptyBlock.style.height = '30px';
                emptyBlock.style.left = gameContainer.offsetWidth + 'px';
                
                // Invert the row calculation to start from bottom
                const baseHeight = 50;
                const rowSpacing = 60;
                const invertedRow = (levelMatrix.length - 1) - row;
                emptyBlock.style.bottom = (baseHeight + (invertedRow * rowSpacing)) + 'px';
                
                document.getElementById('cameraContainer').appendChild(emptyBlock);
                obstacles.push({ element: emptyBlock, type: 'empty' });
                return;
            }

            const obstacle = document.createElement('div');
            
            if (type === 4) { // Finish line
                obstacle.className = 'finishLine';
                obstacle.style.width = '10px';
                obstacle.style.height = '350px';
                obstacle.style.background = '#00ff00';
                obstacle.type = 'finish';
                obstacle.style.position = 'absolute';
                obstacle.style.bottom = '50px'; // Align with ground
            } else if (type === 2) {
                obstacle.className = 'spike';
                obstacle.type = 'spike';
            } else if (type === 3) {
                obstacle.className = 'teleporter';
                obstacle.type = 'teleporter';
            } else if (type === 1) {
                obstacle.className = 'platform';
                obstacle.type = 'platform';
                obstacle.style.width = '45px';
                obstacle.style.height = '45px';
            }
            
            obstacle.style.left = gameContainer.offsetWidth + 'px';
            
            // Invert the row calculation here too
            const baseHeight = 50;
            const rowSpacing = 60;
            const invertedRow = (levelMatrix.length - 1) - row;
            obstacle.style.bottom = (baseHeight + (invertedRow * rowSpacing)) + 'px';
            
            document.getElementById('cameraContainer').appendChild(obstacle);
            obstacles.push({ element: obstacle, type: obstacle.type });
        }

        function levelComplete() {
            isLevelComplete = true;
            levelCompleteElement.style.display = 'block';
            
            // Play completion sound and fade out music
            if (!isMuted) {
                completionSound.currentTime = 0;
                completionSound.play();
                fadeOutMusic();
            }
            
            // Update progress bar
            progressFill.style.width = '100%';
            progressFill.style.background = 'linear-gradient(90deg, #00ff00, #4287f5)';
            progressText.textContent = '100% (Level Complete!)';
            
            cancelAnimationFrame(animationFrameId);
        }

        // Add camera-related variables
        let cameraOffsetY = 0;
        const CAMERA_FOLLOW_THRESHOLD = 50; // Reduced from 100 to make camera more responsive
        const MAX_CAMERA_SPEED = 20; // Increased from 15 to make camera movement smoother

        function updateGame() {
            if (!isLevelStarted || isGameOver || isLevelComplete) return;
            if (isPaused) {
                animationFrameId = requestAnimationFrame(updateGame);
                return;
            }
            
            // Apply game speed to obstacle movement
            const currentSpeed = isPracticeMode ? gameSpeed : 5;  // Default speed is 5
            
            // Create new obstacles less frequently
            if (currentColumn < levelMatrix[0].length && 
                (obstacles.length === 0 || 
                 gameContainer.offsetWidth - obstacles[obstacles.length - 1]?.element.offsetLeft > CONSTANTS.COLUMN_WIDTH)) {
                for (let row = 0; row < levelMatrix.length; row++) {
                    createObstacleFromMatrix(levelMatrix[row][currentColumn], row);
                }
                currentColumn++;
                
                // Only update progress when new obstacles are created
                updateProgress();
            }

            // Player physics
            playerVelocity += gravity;
            const currentBottom = parseInt(window.getComputedStyle(player).bottom);
            let newBottom = currentBottom - playerVelocity;

            // Check ground collision with proper constants
            if (newBottom <= CONSTANTS.GROUND_HEIGHT) {
                newBottom = CONSTANTS.GROUND_HEIGHT;
                isJumping = false;
                doubleJumpAvailable = true;
                playerVelocity = 0;
            }

             // Update player position
            player.style.bottom = newBottom + 'px';
            player.style.left = '100px'; // Keep player's horizontal position fixed

            // Rotate player
            if (isJumping) {
                rotation += 5;
                player.style.transform = 'rotate(' + rotation + 'deg)';
            } else {
                rotation = 0;
                player.style.transform = 'rotate(' + rotation + 'deg)';
            }

            // Update obstacles with optimization
            const playerRect = player.getBoundingClientRect();
            const containerLeft = gameContainer.getBoundingClientRect().left;
            
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                let obstacleLeft = parseInt(obstacle.element.style.left);
                obstacle.element.style.left = (obstacleLeft - currentSpeed) + 'px';

                // Remove off-screen obstacles
                if (obstacleLeft < -50) {
                    obstacle.element.remove();
                    obstacles.splice(i, 1);
                    continue;
                }

                // Only check collisions for nearby obstacles
                if (Math.abs(obstacleLeft - (playerRect.left - containerLeft)) < 100) {
                    const collision = checkCollision(player, obstacle.element);
                    if (collision) {
                        if (obstacle.type === 'finish') {
                            levelComplete();
                        } else if (obstacle.type === 'spike') {
                            gameOver();
                        } else if (obstacle.type === 'teleporter') {
                            player.style.bottom = (parseInt(player.style.bottom) + 100) + 'px';
                            playerVelocity = 0;
                            createParticles();
                        } else if (obstacle.type === 'platform') {
                            handlePlatformCollision(playerRect, obstacle.element);
                        }
                    }
                }
            }

            // Optimize particle updates
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.vy -= 0.2;
                particle.life -= 0.02;
                
                if (particle.life <= 0) {
                    particle.element.remove();
                    particles.splice(i, 1);
                    continue;
                }
                
                particle.element.style.left = (parseFloat(particle.element.style.left) + particle.vx) + 'px';
                particle.element.style.bottom = (parseFloat(particle.element.style.bottom) + particle.vy) + 'px';
                particle.element.style.opacity = particle.life;
            }

            // Use requestAnimationFrame
            if (!isGameOver && !isLevelComplete) {
                animationFrameId = requestAnimationFrame(updateGame);
            }

            // Update camera position
            const containerHeight = gameContainer.offsetHeight;
            const targetCameraY = Math.max(0, newBottom - containerHeight / 2);
            
            // Smooth camera movement
            const cameraDistance = targetCameraY - cameraOffsetY;
            if (Math.abs(cameraDistance) > CAMERA_FOLLOW_THRESHOLD) {
                const cameraSpeed = Math.min(Math.abs(cameraDistance) * 0.1, MAX_CAMERA_SPEED);
                cameraOffsetY += Math.sign(cameraDistance) * cameraSpeed;
            }

            // Apply camera transform (remove negative sign)
            const cameraContainer = document.getElementById('cameraContainer');
            cameraContainer.style.transform = 'translateY(' + cameraOffsetY + 'px)';

            // Update height indicator (using the actual player position)
            const playerIndicator = document.getElementById('playerIndicator');
            const heightIndicator = document.getElementById('heightIndicator');
            const maxHeight = levelMatrix.length * 60;
            const invertedPosition = maxHeight - newBottom;
            const indicatorPosition = (invertedPosition / maxHeight) * heightIndicator.offsetHeight;
            playerIndicator.style.top = Math.min(heightIndicator.offsetHeight, Math.max(0, indicatorPosition)) + 'px';
        }

        // Separate platform collision handling for better organization
        function handlePlatformCollision(playerRect, platform) {
            // Get raw positions without camera influence
            const playerBottom = parseInt(player.style.bottom);
            const platformBottom = parseInt(platform.style.bottom);
            const playerLeft = parseInt(player.style.left);
            const platformLeft = parseInt(platform.style.left);
            
            // Calculate overlap using absolute positions
            const horizontalOverlap = Math.min(playerLeft + 30, platformLeft + 45) - 
                                    Math.max(playerLeft, platformLeft);
            const playerWidth = 30;
            
            if (playerVelocity > 0 && // Moving downward
                playerBottom <= platformBottom + 45 && // Platform height is 45
                playerBottom >= platformBottom &&
                horizontalOverlap > playerWidth * 0.3) {
                
                // Safe landing on platform
                isOnPlatform = true;
                isJumping = false;
                doubleJumpAvailable = true;
                playerVelocity = 0;
                
                // Set player position on top of platform using absolute values
                player.style.bottom = (platformBottom + 45) + 'px';
            } else if (!isPracticeMode) {
                // Side collision check using absolute positions
                const playerCenterX = playerLeft + (playerWidth / 2);
                const significantOverlap = horizontalOverlap > playerWidth * 0.4;
                
                if (significantOverlap && 
                    playerCenterX > platformLeft + 5 && 
                    playerCenterX < platformLeft + 40 &&
                    playerBottom > platformBottom + 15) {
                    gameOver();
                }
            }
        }

        function checkCollision(player, obstacle) {
            if (obstacle.classList.contains('empty-block')) return false;
            
            // Get raw positions without camera influence
            const playerBottom = parseInt(player.style.bottom);
            const playerLeft = parseInt(player.style.left);
            const obstacleBottom = parseInt(obstacle.style.bottom);
            const obstacleLeft = parseInt(obstacle.style.left);
            
            const tolerance = 5;
            const playerSize = 30; // Player width/height
            const obstacleSize = obstacle.type === 'platform' ? 45 : 30;

            return !(playerLeft + playerSize - tolerance < obstacleLeft || 
                    playerLeft + tolerance > obstacleLeft + obstacleSize || 
                    playerBottom + playerSize - tolerance < obstacleBottom || 
                    playerBottom + tolerance > obstacleBottom + obstacleSize);
        }

        function gameOver() {
            if (!isPracticeMode) {  // Only trigger game over if not in practice mode
                isGameOver = true;
                
                if (!isMuted) {
                    backgroundMusic.pause();
                    deathSound.currentTime = 0;
                    deathSound.play();
                }
                
                if (autoRestartEnabled) {
                    // Add a small delay before restarting
                    setTimeout(() => {
                        restartGame();
                    }, 1000); // 1 second delay
                } else {
                    gameOverElement.style.display = 'block';
                }
                
                cancelAnimationFrame(animationFrameId);
            } else {
                // In practice mode, just reset position but keep playing
                player.style.bottom = '50px';
                playerVelocity = 0;
                rotation = 0;
            }
        }

        function restartGame() {
            // Cancel any pending animation frames
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Reset pause state
            isPaused = false;
            pauseMenu.style.display = 'none';
            
            // Reset game state
            isGameOver = false;
            isLevelComplete = false;
            currentColumn = 0;
            gameSpeed = 5;
            playerVelocity = 0;
            rotation = 0;
            isOnPlatform = false;
            
            // Reset UI elements
            levelCompleteElement.style.display = 'none';
            gameOverElement.style.display = 'none';
            player.style.bottom = '50px';
            player.style.transform = 'rotate(0deg)';

            // Clear obstacles and particles
            obstacles.forEach(obstacle => {
                if (obstacle.element && obstacle.element.parentNode) {
                    obstacle.element.remove();
                }
            });
            obstacles = [];
            
            particles.forEach(p => {
                if (p.element && p.element.parentNode) {
                    p.element.remove();
                }
            });
            particles = [];
            
            // Reset jump state
            doubleJumpAvailable = true;
            passedBlocks = 0;
            
            // Reset progress bar
            progressFill.style.width = '0%';
            progressText.textContent = '0%';

            // Reset and replay background music
            if (!isMuted) {
                try {
                    backgroundMusic.pause();
                    backgroundMusic.currentTime = 0;
                    backgroundMusic.play().catch(error => console.log("Audio playback failed:", error));
                } catch (error) {
                    console.log("Audio reset failed:", error);
                }
            }
            
            // Reset player position
            player.style.bottom = CONSTANTS.GROUND_HEIGHT + 'px';
            playerVelocity = 0;
            rotation = 0;
            player.style.transform = 'rotate(0deg)';

            // Reset camera position
            cameraOffsetY = 0;
            document.getElementById('cameraContainer').style.transform = 'translateY(0)';
            
            // Start game loop
            updateGame();
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                jump();
                e.preventDefault();
            }
        });

        document.addEventListener('touchstart', jump);
        restartBtn.addEventListener('click', restartGame);
        // Add this jump function
        function jump() {
            const currentTime = Date.now();
            
            if (!isGameOver && (
                (!isJumping && !isOnPlatform) || 
                (doubleJumpAvailable && currentTime - lastJumpPressTime > jumpBufferTime)
            )) {
                if (isJumping) {
                    doubleJumpAvailable = false;
                }
                isJumping = true;
                isOnPlatform = false;
                playerVelocity = jumpForce;
                createParticles();
                
                lastJumpPressTime = currentTime;
                
                // Play jump sound
                if (!isMuted && jumpSound?.readyState === 4) {
                    jumpSound.currentTime = 0;
                    jumpSound.play().catch(error => console.log("Jump sound failed:", error));
                }
            }
        }

        // Update the progress in updateGame function where we update obstacles
        function updateProgress() {
            // Don't update if game is complete or over
            if (isGameOver || isLevelComplete) return;
            
            const currentTime = Date.now();
            if (currentTime - lastProgressUpdate < progressUpdateInterval) return;
            
            // Ensure currentColumn is valid
            if (typeof currentColumn !== 'number' || currentColumn < 0) {
                currentColumn = 0;
            }
            
            // Calculate progress based on distance to finish line
            passedBlocks = Math.max(0, (currentColumn - 1.1)) * levelMatrix.length;
            // Adjust calculation to reach 100% at finish line
            const progress = (passedBlocks / (totalBlocks - levelMatrix.length)) * 100;
            const clampedProgress = Math.min(Math.round(progress), 100);
            
            // Update progress text with distance to finish
            const blocksToFinish = Math.max(0, totalBlocks - passedBlocks);
            progressText.textContent = clampedProgress + '% (' + blocksToFinish + ' blocks to finish)';
            
            // Smooth progress bar update
            requestAnimationFrame(() => {
                progressFill.style.width = clampedProgress + '%';
                
                // Change progress bar color based on completion
                if (clampedProgress > 75) {
                    progressFill.style.background = 'linear-gradient(90deg, #00ff00, #4287f5)';
                } else if (clampedProgress > 50) {
                    progressFill.style.background = 'linear-gradient(90deg, #ffff00, #00ff00)';
                } else if (clampedProgress > 25) {
                    progressFill.style.background = 'linear-gradient(90deg, #ffa500, #ffff00)';
                }
            });
            
            lastProgressUpdate = currentTime;
        }

        // Add this function to calculate total blocks
        function calculateTotalBlocks() {
            // Find the finish line position (type 4) in the matrix
            finishLinePosition = 0;
            for (let col = 0; col < levelMatrix[0].length; col++) {
                for (let row = 0; row < levelMatrix.length; row++) {
                    if (levelMatrix[row][col] === 4) {
                        finishLinePosition = col;
                        break;
                    }
                }
                if (finishLinePosition > 0) break;
            }
            // Total blocks is the number of columns up to the finish line
            totalBlocks = finishLinePosition * levelMatrix.length;
            if (totalBlocks === 0) {
                console.error('No finish line found in level matrix!');
                totalBlocks = levelMatrix[0].length * levelMatrix.length;
            }
        }

        // Add this after other event listeners
        document.getElementById('muteButton').addEventListener('click', function() {
            toggleMute();
            this.textContent = isMuted ? '🔈' : '';
        });

        // Add music fade out effect
        function fadeOutMusic() {
            if (backgroundMusic.volume > 0.02) {
                backgroundMusic.volume -= 0.02;
                setTimeout(fadeOutMusic, 100);
            } else {
                backgroundMusic.pause();
                backgroundMusic.volume = 0.6; // Reset volume for next time
            }
        }

        // Add this function to handle level start
        function initializeLevel() {
            const settingsMenu = document.getElementById('settingsMenu');
            const volumeSlider = document.getElementById('volumeSlider');
            const volumeValue = document.getElementById('volumeValue');
            const practiceModeCheckbox = document.getElementById('practiceMode');
            const controlMethodSelect = document.getElementById('controlMethod');
            const autoRestartCheckbox = document.getElementById('autoRestart');
            const startLevelBtn = document.getElementById('startLevelBtn');
            const loadingAnimation = document.getElementById('loadingAnimation');

            // Update volume display
            volumeSlider.addEventListener('input', function() {
                const volume = this.value;
                volumeValue.textContent = volume + '%';
                backgroundMusic.volume = volume / 100;
                jumpSound.volume = (volume / 100) * 0.2;
                deathSound.volume = (volume / 100) * 0.7;
                completionSound.volume = (volume / 100) * 0.7;
            });

            // Update practice mode
            practiceModeCheckbox.addEventListener('change', function() {
                isPracticeMode = this.checked;
            });

            // Update control method
            function setupControls(method) {
                // Remove existing listeners
                document.removeEventListener('keydown', handleSpaceJump);
                document.removeEventListener('mousedown', jump);
                
                // Add new listeners based on selection
                if (method === 'space' || method === 'both') {
                    document.addEventListener('keydown', handleSpaceJump);
                }
                if (method === 'click' || method === 'both') {
                    document.addEventListener('mousedown', jump);
                }
            }

            function handleSpaceJump(e) {
                if (e.code === 'Space') {
                    jump();
                    e.preventDefault();
                }
            }

            // Set up initial controls (both)
            setupControls('both');

            // Handle control method changes
            controlMethodSelect.addEventListener('change', function() {
                setupControls(this.value);
            });

            // Fix auto-restart
            autoRestartCheckbox.addEventListener('change', function() {
                autoRestartEnabled = this.checked;
                // Save preference to localStorage (optional)
                localStorage.setItem('autoRestartEnabled', this.checked);
            });

            // Load saved preference (optional)
            const savedAutoRestart = localStorage.getItem('autoRestartEnabled');
            if (savedAutoRestart !== null) {
                autoRestartEnabled = savedAutoRestart === 'true';
                autoRestartCheckbox.checked = autoRestartEnabled;
            }

            // Add the start level button click handler
            startLevelBtn.addEventListener('click', function() {
                const loadingAnimation = document.getElementById('loadingAnimation');
                
                // Show loading animation
                loadingAnimation.style.display = 'block';
                startLevelBtn.style.display = 'none';

                // Try to play audio
                backgroundMusic.play().catch(error => {
                    console.log("Audio autoplay prevented:", error);
                });

                // Hide settings menu and start game
                setTimeout(() => {
                    settingsMenu.style.display = 'none';
                    isLevelStarted = true;
                    updateGame();
                }, 500);
            });

            // Game Speed Control
            const gameSpeedSelect = document.getElementById('gameSpeed');
            gameSpeedSelect.addEventListener('change', function() {
                if (isPracticeMode) {
                    gameSpeed = parseFloat(this.value) * 8; // Adjust base speed
                }
            });

            // Visual Effects Toggle
            const visualEffectsCheckbox = document.getElementById('visualEffects');
            visualEffectsCheckbox.addEventListener('change', function() {
                if (!this.checked) {
                    // Disable particle creation
                    window.createParticles = function() { return; };
                } else {
                    // Re-enable particle creation
                    window.createParticles = function() {
                        for (let i = 0; i < 5; i++) {
                            const particle = document.createElement('div');
                            particle.className = 'particle';
                            const rect = player.getBoundingClientRect();
                            particle.style.left = (rect.left + rect.width/2) + 'px';
                            particle.style.bottom = (parseInt(player.style.bottom) || 50) + 'px';
                            gameContainer.appendChild(particle);
                            
                            const angle = Math.random() * Math.PI * 2;
                            const velocity = 5 + Math.random() * 5;
                            particles.push({
                                element: particle,
                                vx: Math.cos(angle) * velocity,
                                vy: Math.sin(angle) * velocity,
                                life: 1
                            });
                        }
                    };
                }
            });

            // Disable speed control if not in practice mode
            practiceModeCheckbox.addEventListener('change', function() {
                gameSpeedSelect.disabled = !this.checked;
                if (!this.checked) {
                    gameSpeedSelect.value = "1";
                    gameSpeed = 8; // Reset to default speed
                }
            });

            // Cleanup function for event listeners
            const cleanup = () => {
                document.removeEventListener('keydown', handleSpaceJump);
                document.removeEventListener('mousedown', jump);
                document.removeEventListener('touchstart', jump);
            };
            
            // Store cleanup function for potential future use
            window.cleanupLevelEvents = cleanup;
        }

        // Helper function for jump handling
        function handleJump(e) {
            if (e.type === 'keydown' && e.code !== 'Space') return;
            jump();
        }

        

        // Use requestAnimationFrame more efficiently
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            updateGame(deltaTime);
        }

        // Add proper asset preloading
        async function preloadAssets() {
            await Promise.all([
                loadAudio(),
                loadImages(),
                loadLevelData()
            ]);
        }

        function togglePause() {
            if (isGameOver || isLevelComplete) return;
            
            isPaused = !isPaused;
            const pauseButton = document.getElementById('pauseButton');
            
            if (isPaused) {
                pauseMenu.style.display = 'block';
                pauseButton.textContent = '▶';  // Play icon
                if (!isMuted && backgroundMusic) {
                    backgroundMusic.pause();
                }
            } else {
                pauseMenu.style.display = 'none';
                pauseButton.textContent = '⏸';  // Pause icon
                if (!isMuted && backgroundMusic) {
                    backgroundMusic.play().catch(error => console.log("Audio resume failed:", error));
                }
            }
        }

        // Add pause key listener
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyP') {
                togglePause();
            }
        });

        // Add resume button listener
        document.getElementById('resumeBtn').addEventListener('click', togglePause);

        // Add restart from pause button listener
        document.getElementById('restartFromPauseBtn').addEventListener('click', () => {
            pauseMenu.style.display = 'none';
            isPaused = false;
            restartGame();
        });

        // Add this with your other event listeners
        document.getElementById('pauseButton').addEventListener('click', togglePause);
        
        document.getElementById('nextLevelBtn').addEventListener('click', function() {
            window.location.href = 'teleporterdashmenu.html';  // Return to menu if no level2 exists yet
        });
        // Initialize the game
        window.onload = function() {
            
            // Create camera container if it doesn't exist
            if (!document.getElementById('cameraContainer')) {
                const cameraContainer = document.createElement('div');
                cameraContainer.id = 'cameraContainer';
                
                // Move existing elements into camera container
                const elementsToMove = ['player', 'ground', 'progressContainer'];
                elementsToMove.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        cameraContainer.appendChild(element);
                    }
                });
                
                gameContainer.insertBefore(cameraContainer, gameContainer.firstChild);
            }

            // Create height indicator if it doesn't exist
            if (!document.getElementById('heightIndicator')) {
                const heightIndicator = document.createElement('div');
                heightIndicator.id = 'heightIndicator';
                const playerIndicator = document.createElement('div');
                playerIndicator.id = 'playerIndicator';
                heightIndicator.appendChild(playerIndicator);
                gameContainer.appendChild(heightIndicator);
            }

            setupAudio();
            calculateTotalBlocks();
            initializeLevel();
        };   
    <\/script>
</body>
</html>`;
            

            /// Add level HTML to zip
            zip.file(levelName + '.html', levelContent);

            // For custom music, add it directly to the zip
            if (musicSelect.value === 'custom' && customMusicFile) {
                zip.file('LevelSoundtracks/' + musicFile, customMusicFile);
            }
                    
            // Generate and download the zip
            zip.generateAsync({type: 'blob'})
                .then(function(content) {
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = levelName + '.zip';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
        });

        // Add this for handling custom music file selection
        customMusicInput.addEventListener('change', function(e) {
            if (e.target.files.length > 0) {
                customMusicFile = e.target.files[0];
                // Update music select to show custom file name
                const option = document.createElement('option');
                option.value = 'custom';
                option.text = 'Custom: ' + customMusicFile.name;
                option.selected = true;
                
                // Remove any existing custom option
                Array.from(musicSelect.options).forEach(opt => {
                    if (opt.value === 'custom') musicSelect.removeChild(opt);
                });
                
                musicSelect.add(option);
            }
        });

        // Test level functionality
        testBtn.addEventListener('click', () => {
            const levelData = {
                name: levelNameInput.value || 'Test Level',
                music: musicSelect.value,
                matrix: levelMatrix
            };
            
            // Store level data in localStorage for testing
            localStorage.setItem('testLevel', JSON.stringify(levelData));
            
            // Open test window
            window.open('leveltest.html', '_blank');
        });

        // Clear grid
        clearBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear the grid?')) {
                levelMatrix = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0));
                updateGridVisuals();
            }
        });

        // Initialize the editor
        createGrid();

        // Prevent default drag behavior
        grid.addEventListener('dragstart', e => e.preventDefault());
    </script>
</body>
</html> 
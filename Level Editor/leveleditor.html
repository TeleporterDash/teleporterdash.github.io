<!DOCTYPE html>
<html>
<head>
    <title>Teleporter Dash Level Creator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');

        body {
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            background: #1a1a1a;
            font-family: 'Orbitron', sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #mainContainer {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            width: 100%;
        }

        #leftPanel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 800px;
        }

        #rightPanel {
            flex: 1;
            min-width: 300px;
        }

        #gridContainer {
            width: 100%;
            border: 2px solid #0F9D58;
            border-radius: 5px;
            overflow: auto;
            background-color: #1a1a1a;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-width, 100), 50px);
            grid-template-rows: repeat(var(--grid-height, 5), 55px);
            gap: 1px;
            background: #1a1a1a;
        }

        .cell {
            width: 50px;
            height: 55px;
            border: 1px solid #403d3d;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .cell:hover {
            border-color: #0F9D58;
            border-width: 1.5px;
            
        }

        .cell.empty {
            background: transparent;
        }

        .cell.platform {
            background: #4287f5;
        }

        .cell.spike {
            background: #ff0000;
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        }

        .cell.teleporter {
            background: linear-gradient(to right, #ff00ff, #8c00ff);
            animation: glow 1s infinite alternate;
        }

        .cell.finish {
            background: #00ff00;
        }

        .cell.color-row {
            background: transparent;
            border: 1px solid #666;
            opacity: 1;
        }

        .cell.color-row:hover {
            border-color: #0F9D58;
            opacity: 0.8;
        }

        #editorControls {
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group input,
        .control-group select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #4285F4;
            background: #1a1a1a;
            color: #ffffff;
            font-family: 'Orbitron', sans-serif;
            caret-color: #4285F4;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .control-group input:focus,
        .control-group select:focus {
            border-color: #0F9D58;
            box-shadow: 0 0 5px rgba(15, 157, 88, 0.5);
        }

        .control-group input::placeholder {
            color: #666;
            opacity: 1;
        }

        .control-group select {
            cursor: pointer;
        }

        .control-group select option {
            background: #1a1a1a;
            color: #ffffff;
        }

        .tool-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .tool {
            padding: 10px;
            background: #4285F4;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .tool.active {
            background: #0F9D58;
        }

        .action-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .action-group button {
            padding: 10px 20px;
            background: #0F9D58;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .action-group button:hover {
            background: #0B8043;
        }

        #previewMusic {
            padding: 5px 10px;
            background: #4285F4;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            margin-top: 5px;
        }

        @keyframes glow {
            from { box-shadow: 0 0 5px #ff00ff; }
            to { box-shadow: 0 0 20px #ff00ff; }
        }

        #exportArea {
            width: 100%;
            height: 100px;
            margin-top: 20px;
            background: #222;
            color: white;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            font-family: monospace;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            color: #0F9D58;
            text-shadow: 0 0 10px #0F9D58;
        }

        .section-header {
            color: #0F9D58;
            font-family: 'Orbitron', sans-serif;
            margin: 10px 0;
            font-size: 1.5em;
        }

        .tool[data-type="c"] {
            background: linear-gradient(45deg, #ff0000, #00ff00, #0000ff);
        }

        #gameContainer {
            --from-color: #000000;
            --to-color: #000000;
            background-color: var(--from-color);
            will-change: background-color;
        }

        @keyframes backgroundTransition {
            0% { 
                background-color: var(--from-color);
            }
            100% { 
                background-color: var(--to-color);
            }
        }

        .controls button {
            margin: 5px;
            padding: 10px;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
        }

        .controls button:hover {
            background-color: #45a049;
        }

        #draftsList {
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #0F9D58;
            border-radius: 5px;
            padding: 10px;
            background-color: rgba(15, 157, 88, 0.1);
            box-sizing: border-box;
        }

        .draft-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background-color: rgba(15, 157, 88, 0.2);
            border-radius: 5px;
            font-family: 'Orbitron', sans-serif;
        }

        .draft-item span {
            margin-right: 10px;
            color: #0F9D58;
        }

        .draft-item button {
            padding: 5px 10px;
            margin-left: 5px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            background-color: #0F9D58;
            color: white;
            font-family: 'Orbitron', sans-serif;
        }

        .draft-item button:hover {
            background-color: #0b8043;
        }
    </style>
</head>
<body>
    <h1 class="header">Teleporter Dash Level Creator</h1>
    <div id="mainContainer">
        <div id="leftPanel">
            <div id="gridContainer">
                <div id="grid"></div>
            </div>
            <h2 class="section-header">Drafts</h2>
            <div id="draftsList"></div>
        </div>
        <div id="rightPanel">
            <div id="editorControls">
                <div class="control-group">
                    <label for="levelName">Level Name:</label>
                    <input type="text" id="levelName" placeholder="Enter level name">
                </div>
                <div class="control-group">
                    <label for="authorName">Author:</label>
                    <input type="text" id="authorName" placeholder="Enter author name">
                </div>
                <div class="control-group">
                    <label for="difficulty">Difficulty:</label>
                    <select id="difficulty">
                        <option value="Easy">Easy</option>
                        <option value="Normal">Normal</option>
                        <option value="Hard">Hard</option>
                        <option value="Harder">Harder</option>
                        <option value="Expert">Expert</option>
                        <option value="Insane">Insane</option>
                        <option value="Extreme">Extreme</option>
                        <option value="Easy Demon">Easy Demon</option>
                        <option value="Medium Demon">Medium Demon</option>
                        <option value="Super Demon">Super Demon</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="musicSelect">Background Music:</label>
                    <select id="musicSelect">
                        <option value="level1.mp3">Stereo Madness</option>
                        <option value="level2.mp3">Back on Track</option>
                        <option value="level3.mp3">Polargeist</option>
                        <option value="level4.mp3">Dry Out</option>
                        <option value="level5.mp3">Base After Base</option>
                        <option value="custom">Custom Music...</option>
                    </select>
                    <input type="file" id="customMusicInput" accept="audio/*" style="display: none;">
                    <button id="previewMusic">Preview Music</button>
                </div>

                <div class="control-group">
                    <label>Grid Size:</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div>
                            <label for="gridWidth">Width:</label>
                            <input type="number" id="gridWidth" value="100" style="width: 70px;">
                        </div>
                        <div>
                            <label for="gridHeight">Height:</label>
                            <input type="number" id="gridHeight" value="5" style="width: 70px;">
                        </div>
                        <button id="updateGridSize" style="padding: 5px 10px; background: #4285F4; border: none; border-radius: 5px; color: white; cursor: pointer;">
                            Update Grid
                        </button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Tools:</label>
                    <div class="tool-group">
                        <button class="tool active" data-type="0">Empty</button>
                        <button class="tool" data-type="1">Platform</button>
                        <button class="tool" data-type="2">Spike</button>
                        <button class="tool" data-type="3">Teleporter</button>
                        <button class="tool" data-type="4">Finish</button>
                        <button class="tool" data-type="c">Color</button>
                    </div>
                </div>

                <div class="control-group" id="colorPickerGroup" style="display: none;">
                    <label>Color:</label>
                    <select id="colorPicker">
                        <option value="1">Black</option>
                        <option value="2">Purple</option>
                        <option value="3">Green</option>
                        <option value="4">Red</option>
                        <option value="5">Blue</option>
                    </select>
                </div>

                <div class="action-group">
                    <button id="saveDraftBtn">Save Draft</button>
                    <button id="testBtn">Test Level</button>
                    <button id="exportBtn">Export Level</button>
                    <button id="importBtn">Import Level</button>
                    <button id="clearBtn">Clear Grid</button>
                </div>

                <textarea id="importArea" style="display: none;"></textarea>
            </div>
        </div>
    </div>
    <audio id="musicPreview" src="../Sound/Level Soundtracks/"></audio>
    <script src="https://cdn.jsdelivr.net/gh/dduponchel/jszip@issue477/dist/jszip.js"></script>
    <script>
        // =====  Variables =====
            // // Buttons 
        const grid = document.getElementById('grid');
        const tools = document.querySelectorAll('.tool');
        const exportBtn = document.getElementById('exportBtn');
        const testBtn = document.getElementById('testBtn');
        const clearBtn = document.getElementById('clearBtn');
        const exportArea = document.getElementById('exportArea');
        const musicSelect = document.getElementById('musicSelect');
        const musicPreview = document.getElementById('musicPreview');
        const previewMusicBtn = document.getElementById('previewMusic');
        const levelNameInput = document.getElementById('levelName');
        const bgColorSelect = document.getElementById('bgColor');

            // // Changeable Variables 
        let hasUnsavedChanges = false;
        let lastExportedMatrix = null;
        let currentTool = '0';
        let isMouseDown = false;
        let nextLevelId = 0;

            // // Custom Music
        let customMusicFile = null;
        const customMusicInput = document.getElementById('customMusicInput');

            // // Colors
        const COLOR_MAP = {
            0: '#000000',     // Default black
            '-1': '#000000',  // Black
            '-2': '#913291',  // Dark purple
            '-3': '#339033',  // Dark green
            '-4': '#963535',  // Dark red
            '-5': '#2a2a8d'   // Dark blue
        };         
        let selectedColor = 0;  // Default color value
        
            // // Grid
        const gridWidthInput = document.getElementById('gridWidth');
        const gridHeightInput = document.getElementById('gridHeight');
        const updateGridSizeBtn = document.getElementById('updateGridSize');
        const gridContainer = document.getElementById('gridContainer'); // Get grid container
        let GRID_WIDTH = 100;
        let GRID_HEIGHT = 5;
            // // // Initialize Level Matrix
        let levelMatrix = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0));

            // // Level Registry
        const LEVELS_REGISTRY_KEY = 'teleporterDash_levels';

            // // IndexedDB
        let db;
        const DB_NAME = 'LevelEditorDB';
        const DB_VERSION = 1;
        const DRAFTS_STORE = 'levelDrafts';
        const TEST_STORE = 'testLevel';


        // ===== IndexedDB ======
            // // Initialize IndexedDB
        const dbInit = indexedDB.open(DB_NAME, DB_VERSION);

            // // Errors
        dbInit.onerror = (event) => {
            console.error('Database error:', event.target.error);
        };

            // // Database Updates
        dbInit.onupgradeneeded = (event) => {
            db = event.target.result;
            if (!db.objectStoreNames.contains(DRAFTS_STORE)) {
                const store = db.createObjectStore(DRAFTS_STORE, { keyPath: 'id', autoIncrement: true });
                store.createIndex('lastModified', 'lastModified');
                store.createIndex('title', 'title');
            }
            if (!db.objectStoreNames.contains(TEST_STORE)) {
                db.createObjectStore(TEST_STORE, { keyPath: 'id' });
            }
        };

            // // Continue
        dbInit.onsuccess = (event) => {
            db = event.target.result;
            loadDraftsList(); // Load existing drafts when DB is ready
        };


        // ===== Grid =====
            // // Update Grid Size
        function updateGridSize() {
            const width = parseInt(gridWidthInput.value) || 100;
            const height = parseInt(gridHeightInput.value) || 5;
            
            // Update CSS variables for grid dimensions
            document.documentElement.style.setProperty('--grid-width', width);
            document.documentElement.style.setProperty('--grid-height', height);
            
            // Calculate and set container height based on row height
            const rowHeight = 55; // matches the CSS grid-template-rows value
            const containerHeight = (height * rowHeight) + 20; // +2 for borders
            gridContainer.style.height = containerHeight + 'px';
            
            // Create new matrix preserving existing data
            const newMatrix = Array(height).fill().map((_, row) => {
                if (row < levelMatrix.length) {
                    // Copy existing row, extending with zeros if new width is larger
                    const existingRow = levelMatrix[row] || [];
                    return Array(width).fill(0).map((_, col) => 
                        col < existingRow.length ? existingRow[col] : 0
                    );
                } else {
                    // New rows are initialized with zeros, first column as platform
                    return Array(width).fill(0);
                }
            });
            
            // Ensure first row is all platforms
            newMatrix[0] = Array(width).fill(1);
            
            // Update global variables and matrix
            GRID_WIDTH = width;
            GRID_HEIGHT = height;
            levelMatrix = newMatrix;
            
            createGrid();
            updateGridVisuals();
        }

            // // Create Initial Grid and Update Dimensions
        function createGrid() {
            grid.innerHTML = '';
            
            // Set grid dimensions using current GRID_WIDTH and GRID_HEIGHT
            grid.style.setProperty('--grid-width', GRID_WIDTH);
            grid.style.setProperty('--grid-height', GRID_HEIGHT);
            
            // Create the actual grid cells
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const cell = document.createElement('div');
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // Set initial cell state based on matrix
                    const value = levelMatrix[row][col];
                    
                    if (row === 0) {
                        cell.className = 'cell color-row';
                        const colorValue = value <= 0 ? value : 0; // Ensure color values are negative or 0
                        cell.style.backgroundColor = COLOR_MAP[colorValue] || COLOR_MAP[0];
                    } else {
                        cell.className = 'cell';
                        if (value > 0) {
                            switch(value) {
                                case 1: cell.classList.add('platform'); break;
                                case 2: cell.classList.add('spike'); break;
                                case 3: cell.classList.add('teleporter'); break;
                                case 4: cell.classList.add('finish'); break;
                            }
                        }
                    }
                    
                    cell.addEventListener('mousedown', (e) => {
                        isMouseDown = true;
                        handleCellClick(e);
                    });
                    
                    cell.addEventListener('mouseover', (e) => {
                        if (isMouseDown) handleCellClick(e);
                    });
                    
                    grid.appendChild(cell);
                }
            }
        }

            // // Handle Matrix Changes
        function hasMatrixChanged() {
            if (!lastExportedMatrix) return levelMatrix.some(row => row.some(cell => cell !== 0));
            return JSON.stringify(levelMatrix) !== JSON.stringify(lastExportedMatrix);
        }

            // // Handle Clicks in Grid
        function handleCellClick(e) {
            const cell = e.target;
            if (!cell.dataset.row || !cell.dataset.col) return;
            
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            if (currentTool === 'c' && row === 0) {
                // Force color to be applied with full opacity
                levelMatrix[row][col] = selectedColor;
                cell.style.backgroundColor = COLOR_MAP[selectedColor];
                cell.style.opacity = '1';
            } else if (row === 0) {
                return;
            } else {
                levelMatrix[row][col] = parseInt(currentTool);
            }
            
            updateGridVisuals();
        }

            // // Update Grid 
        function updateGridVisuals() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                if (!cell.dataset.row || !cell.dataset.col) return;
                
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                if (row === 0) {
                    // Handle color row
                    const colorValue = levelMatrix[0][col];
                    cell.className = 'cell color-row';
                    cell.style.backgroundColor = COLOR_MAP[colorValue] || COLOR_MAP[0];
                } else {
                    // Handle game cells
                    const value = levelMatrix[row][col];
                    cell.className = 'cell';
                    switch(value) {
                        case 0: cell.classList.add('empty'); break;
                        case 1: cell.classList.add('platform'); break;
                        case 2: cell.classList.add('spike'); break;
                        case 3: cell.classList.add('teleporter'); break;
                        case 4: cell.classList.add('finish'); break;
                    }
                }
            });
        }


        // ===== Level Registry =====
        function getLevelsRegistry() {
                    return JSON.parse(localStorage.getItem(LEVELS_REGISTRY_KEY) || '[]');
                }


        // ===== Export =====
            // // Get Music Path
        function getMusicPath(musicValue, forExport = false, isTest = false) {
            if (musicValue === 'custom') {
                const file = customMusicInput.files[0];
                if (file) {
                    if (forExport) {
                        // For export, use the filename
                        return `../Sound/Level Soundtracks/${file.name}`;
                    } else if (!isTest) {
                        // For preview, use Object URL
                        return URL.createObjectURL(file);
                    }
                    // For test, the path will be handled by gameloader.html
                }
            } else {
                // For built-in music, return the proper path
                return `../Sound/Level Soundtracks/${musicValue}`;
            }
            return '../Sound/Level Soundtracks/level1.mp3'; // Default fallback
        }
     
            // // Initialize the editor
        createGrid();

            // // Checks
                // // // Next Level ID
        function getNextLevelId() {
            const id = nextLevelId++;
            localStorage.setItem('nextLevelId', nextLevelId);
            return id;
        }

            // // Sanitize Matrix
        function sanitizeMatrix(matrix) {
            return matrix.map(row => 
                row.map(cell => 
                    cell === null || cell === undefined ? 0 : cell
                )
            );
        }


        // ===== Testing Functionality =====
        async function testLevel() {
            // Sanitize the matrix first
            const cleanMatrix = sanitizeMatrix(levelMatrix);
            
            const musicValue = musicSelect.value || 'level1.mp3';
            let musicData = null;
            
            // If it's custom music, get the file data
            if (musicValue === 'custom' && customMusicInput.files[0]) {
                const file = customMusicInput.files[0];
                musicData = {
                    name: file.name,
                    type: file.type,
                    data: await file.arrayBuffer()
                };
            }
            
            const testData = {
                id: 'currentTest', // Use a fixed ID to always update the same record
                matrix: cleanMatrix,
                author: document.getElementById('authorName').value || 'Unknown Author',
                difficulty: document.getElementById('difficulty').value || 'Normal',
                musicValue: musicValue,
                musicData: musicData
            };

            const transaction = db.transaction([TEST_STORE], 'readwrite');
            const store = transaction.objectStore(TEST_STORE);
            
            try {
                await store.put(testData);
                // Open the test page in a new window
                window.open('../Levels/gameloader.html?test=true&levelId=currentTest', '_blank');
            } catch (error) {
                console.error('Error saving test level:', error);
                alert('Failed to save test level');
            }
        }


        // ===== Color =====
            // // Color Indicator Updates
        function updateSelectedColorIndicator() {
            const colorCell = document.querySelector('.cell.color-row');
            if (colorCell) {
                colorCell.style.backgroundColor = COLOR_MAP[selectedColor] || COLOR_MAP[0];
            }
        }
            // // Color Selection Handler
        function handleColorSelection(colorNum) {
            selectedColor = -colorNum;
            updateSelectedColorIndicator();
        }

            // // Color Picker
        const colorPicker = document.getElementById('colorPicker');
        colorPicker.innerHTML = `
            <option value="1">Black</option>
            <option value="2">Purple</option>
            <option value="3">Green</option>
            <option value="4">Red</option>
            <option value="5">Blue</option>
        `;

        
        // ===== Importing Functionality =====
        function importMatrix() {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.js,.txt,application/json';
            
            fileInput.onchange = function(e) {
                const file = e.target.files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const content = e.target.result;
                        let parsed;
                        
                        // Try to extract matrix from different formats
                        if (content.includes('window.levelData')) {
                            // Extract the entire levelData object
                            const levelDataMatch = content.match(/window\.levelData\s*=\s*({[\s\S]*?});/);
                            if (levelDataMatch) {
                                // Parse the levelData object
                                const levelData = Function(`return ${levelDataMatch[1]}`)();
                                parsed = levelData.matrix;
                                
                                // Update level name if available
                                if (levelData.title) {
                                    document.getElementById('levelName').value = levelData.title;
                                }
                                
                                // Update author name if available
                                if (levelData.author) {
                                    document.getElementById('authorName').value = levelData.author;
                                }
                                
                                // Update difficulty if available
                                if (levelData.difficulty) {
                                    const difficultySelect = document.getElementById('difficulty');
                                    Array.from(difficultySelect.options).forEach(option => {
                                        if (option.value === levelData.difficulty) {
                                            option.selected = true;
                                        }
                                    });
                                }
                                
                                // Update music selection if available
                                if (levelData.music) {
                                    const musicPath = levelData.music.split('/').pop();
                                    const musicSelect = document.getElementById('musicSelect');
                                    Array.from(musicSelect.options).forEach(option => {
                                        if (option.value === musicPath) {
                                            option.selected = true;
                                        }
                                    });
                                }
                            }
                        } else if (content.includes('matrix:')) {
                            // Handle matrix: [...] format
                            const matrixMatch = content.match(/matrix:\s*(\[[\s\S]*?\])/);
                            if (matrixMatch) {
                                parsed = JSON.parse(matrixMatch[1].replace(/\s+/g, ''));
                            }
                        } else {
                            // Try direct JSON array
                            parsed = JSON.parse(content);
                        }

                        if (Array.isArray(parsed) && Array.isArray(parsed[0])) {
                            // Update grid dimensions to match imported matrix
                            GRID_HEIGHT = parsed.length;
                            GRID_WIDTH = parsed[0].length;
                            gridWidthInput.value = GRID_WIDTH;
                            gridHeightInput.value = GRID_HEIGHT;
                            hasUnsavedChanges = true;
                            lastExportedMatrix = null;
                            
                            // Update level matrix
                            levelMatrix = parsed;
                            
                            // Recreate grid with new dimensions and data
                            createGrid();
                            updateGridVisuals();
                        } else {
                            throw new Error('Invalid matrix format');
                        }
                    } catch (e) {
                        alert('Invalid matrix format! ' + e.message);
                        console.error(e);
                    }
                };
                
                reader.readAsText(file);
            };
            
            fileInput.click();
        }

       
        // ===== Draft Functionality =====
            // // Function to save current level as draft
        async function saveDraft(title = 'Untitled Draft') {
            try {
                // Clean the matrix - ensure only numbers
                const cleanMatrix = levelMatrix.map(row => 
                    row.map(cell => {
                        // Convert to number, default to 0 if not a valid number
                        const num = Number(cell);
                        return isNaN(num) ? 0 : num;
                    })
                );

                const draftData = {
                    title: levelNameInput.value || title,
                    matrix: cleanMatrix,
                    author: document.getElementById('authorName').value || 'Unknown Author',
                    difficulty: document.getElementById('difficulty').value || 'Normal',
                    musicValue: document.getElementById('musicSelect').value || 'level1.mp3',
                    lastModified: new Date().toISOString()
                };

                // Debug log
                console.log('Saving draft data:', JSON.stringify(draftData));

                const transaction = db.transaction([DRAFTS_STORE], 'readwrite');
                const store = transaction.objectStore(DRAFTS_STORE);
                await store.add(draftData);
                
                alert('Draft saved successfully!');
                loadDraftsList(); // Refresh the drafts list
            } catch (error) {
                console.error('Error saving draft:', error);
                console.error('Draft data that caused error:', levelMatrix);
                alert('Failed to save draft: ' + error.message);
            }
        }

            // // Load Drafts
        async function loadDraft(draftId) {
            const transaction = db.transaction([DRAFTS_STORE], 'readonly');
            const store = transaction.objectStore(DRAFTS_STORE);
            const request = store.get(draftId);

            request.onsuccess = () => {
                const draft = request.result;
                if (draft) {
                    levelMatrix = draft.matrix;
                    GRID_HEIGHT = draft.matrix.length;
                    GRID_WIDTH = draft.matrix[0].length;
                    
                    // Update input values
                    gridWidthInput.value = GRID_WIDTH;
                    gridHeightInput.value = GRID_HEIGHT;
                    
                    // Update grid container height
                    const rowHeight = 55;
                    const containerHeight = (GRID_HEIGHT * rowHeight) + 2;
                    gridContainer.style.height = containerHeight + 'px';
                    
                    // Update other fields
                    levelNameInput.value = draft.title;
                    document.getElementById('authorName').value = draft.author || '';
                    document.getElementById('difficulty').value = draft.difficulty || 'Normal';
                    musicSelect.value = draft.musicValue || 'level1.mp3';
                    
                    // Update grid
                    document.documentElement.style.setProperty('--grid-width', GRID_WIDTH);
                    document.documentElement.style.setProperty('--grid-height', GRID_HEIGHT);
                    createGrid();
                    updateGridVisuals();
                    
                    alert('Draft loaded successfully!');
                }
            };
        }

            // // Delete Drafts
        async function deleteDraft(draftId) {
            if (!confirm('Are you sure you want to delete this draft?')) return;

            const transaction = db.transaction([DRAFTS_STORE], 'readwrite');
            const store = transaction.objectStore(DRAFTS_STORE);
            const request = store.delete(draftId);

            request.onsuccess = () => {
                alert('Draft deleted successfully!');
                loadDraftsList();
            };
        }

            // // Load Draft List
        async function loadDraftsList() {
            const transaction = db.transaction([DRAFTS_STORE], 'readonly');
            const store = transaction.objectStore(DRAFTS_STORE);
            const request = store.index('lastModified').openCursor(null, 'prev');
            
            const draftsList = document.getElementById('draftsList');
            draftsList.innerHTML = '';

            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    const draft = cursor.value;
                    const draftElement = document.createElement('div');
                    draftElement.className = 'draft-item';
                    draftElement.innerHTML = `
                        <span>${draft.title}</span>
                        <span>${new Date(draft.lastModified).toLocaleString()}</span>
                        <button onclick="loadDraft(${draft.id})">Load</button>
                        <button onclick="deleteDraft(${draft.id})">Delete</button>
                    `;
                    draftsList.appendChild(draftElement);
                    cursor.continue();
                }
            };
        }

            // // Auto Save Drafts
        let autoSaveTimeout;
        function scheduleAutoSave() {
            clearTimeout(autoSaveTimeout);
            autoSaveTimeout = setTimeout(() => {
                if (hasMatrixChanged()) {
                    saveDraft();
                }
            }, 30000); // Auto-save after 30 seconds of inactivity
        }
                // // // Update existing functions to trigger auto-save
        const originalUpdateCell = updateCell;
        updateCell = function(row, col, value) {
            originalUpdateCell(row, col, value);
            scheduleAutoSave();
        };

            // // Draft Event Listeners
                // // // Add event listener for save draft button
        document.getElementById('saveDraftBtn').addEventListener('click', saveDraft);


        // ===== Event Listeners =====
            // // Import Button Event Listener 
        document.getElementById('importBtn').addEventListener('click', importMatrix);

            // // Track Grid Changes 
        function updateCell(row, col, value) {
            levelMatrix[row][col] = value;
            hasUnsavedChanges = true;
            updateGridVisuals();
        }
            
            // // Unsaved Changes Check
        window.addEventListener('beforeunload', (e) => {
            if (hasMatrixChanged()) {
                e.preventDefault();
                // Most browsers will show their own message, but a custom one for older browsers
                 e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
            }
        });

            // // Color Picker
        colorPicker.addEventListener('change', function() {
            handleColorSelection(parseInt(this.value));
        });

        // Clean up object URLs when leaving the page
        window.addEventListener('beforeunload', () => {
            if (musicPreview.src.startsWith('blob:')) {
                URL.revokeObjectURL(musicPreview.src);
            }
        });

            // // Prevent default drag behavior
        grid.addEventListener('dragstart', e => e.preventDefault());

            // // Custom Music File Selection
        customMusicInput.addEventListener('change', function(e) {
            if (e.target.files.length > 0) {
                customMusicFile = e.target.files[0];
                // Update music select to show custom file name
                const option = document.createElement('option');
                option.value = 'custom';
                option.text = 'Custom: ' + customMusicFile.name;
                option.selected = true;
                
                // Remove any existing custom option
                Array.from(musicSelect.options).forEach(opt => {
                    if (opt.value === 'custom') musicSelect.removeChild(opt);
                });
                
                musicSelect.add(option);
                
                // Reset preview button
                previewMusicBtn.textContent = 'Preview Music';
                musicPreview.pause();
                musicPreview.currentTime = 0;
            }
        });

            // // Test Level Button
        testBtn.addEventListener('click', () => {
            testLevel();
        });

            // // Clear Grid
        clearBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear the grid?')) {
                levelMatrix = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0));
                updateGridVisuals();
                hasUnsavedChanges = false;
                lastExportedMatrix = null;
            }
        });

            // // Export Button 
        exportBtn.addEventListener('click', () => {
            const levelName = levelNameInput.value || 'Untitled Level';
            const authorName = document.getElementById('authorName').value || 'Unknown Author';
            const difficulty = document.getElementById('difficulty').value || 'Normal';
            const musicPath = getMusicPath(musicSelect.value, true);  // Pass true for export
            const levelId = getNextLevelId();
            const zip = new JSZip();
            
            // Create level file content
            const jsContent = `// Level ${levelId}: ${levelName}
window.levelData = {
    id: ${levelId},
    title: "${levelName}",
    author: "${authorName}",
    difficulty: "${difficulty}",
    matrix: ${JSON.stringify(levelMatrix, null, 4)},
    music: "${musicPath}",
    colorTransitionDuration: 0.5, 
    colorTransitionDelay: 0.1    
};`;

            // Add files to zip
            zip.file(`Levels/level${levelId}.js`, jsContent);
            
            // If using custom music, add it to the zip
            if (musicSelect.value === 'custom' && customMusicInput.files[0]) {
                const musicFile = customMusicInput.files[0];
                zip.file(`Sound/Level Soundtracks/${musicFile.name}`, musicFile);
            }

            // Create README content
            const readmeContent = [
                `Level: ${levelName}`,
                `Author: ${authorName}`,
                `Difficulty: ${difficulty}`,
                `Level ID: ${levelId}`,
                `Music File Required: ${musicPath}`,
                ``,
                `Setup Instructions:`,
                `1. Extract all files from this zip`,
                `2. Copy "level${levelId}.js" to the Levels directory`,
                musicSelect.value === 'custom' ? `3. Copy the music file to Sound/Level Soundtracks directory` : '',
                ``,
                `The level will automatically appear in the menu when you restart the game.`
            ].filter(line => line !== '').join('\n');

            zip.file('README.txt', readmeContent);

            // Generate and download the zip
            zip.generateAsync({type: 'blob'})
                .then(function(content) {
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${levelName}_level${levelId}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
            // After successful export, save the current state
            lastExportedMatrix = JSON.parse(JSON.stringify(levelMatrix));
            hasUnsavedChanges = false;

            alert('You will be redirected to a Google Form to submit your level in a few seconds.');
            setTimeout(() => {
            window.location.href = 'https://forms.gle/2hGA3QKpQmN2akA99';
            }, 3000);

        });

            // // Preview Music 
        previewMusicBtn.addEventListener('click', () => {
            if (musicPreview.paused) {
                // Revoke previous Object URL if it exists
                if (musicPreview.src.startsWith('blob:')) {
                    URL.revokeObjectURL(musicPreview.src);
                }
                
                const musicPath = getMusicPath(musicSelect.value);
                musicPreview.src = musicPath;
                console.log('Setting music path:', musicPath);
                
                musicPreview.play().catch(error => {
                    console.error('Failed to play music:', error);
                    alert('Failed to play music preview. Please ensure you have selected a valid audio file.');
                    previewMusicBtn.textContent = 'Preview Music';
                });
                
                previewMusicBtn.textContent = 'Stop Preview';
            } else {
                // Cleanup Object URL when stopping
                if (musicPreview.src.startsWith('blob:')) {
                    URL.revokeObjectURL(musicPreview.src);
                }
                musicPreview.pause();
                musicPreview.currentTime = 0;
                previewMusicBtn.textContent = 'Preview Music';
            }
        });

            // // Stop drawing when mouse is released
        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

            // // Tool Selection
        tools.forEach(tool => {
            tool.addEventListener('click', () => {
                tools.forEach(t => t.classList.remove('active'));
                tool.classList.add('active');
                currentTool = tool.dataset.type;
                
                // Show/hide color picker based on tool selection
                const colorPickerGroup = document.getElementById('colorPickerGroup');
                colorPickerGroup.style.display = currentTool === 'c' ? 'block' : 'none';
            });
        });

            // // Update Button
        updateGridSizeBtn.addEventListener('click', updateGridSize);

            // // Music Selection
        musicSelect.addEventListener('change', function() {
            if (this.value === 'custom') {
                customMusicInput.click();
            }
        });
    </script>
</body>
</html>